{"meta":{"title":"Wilder's Bolg","subtitle":null,"description":null,"author":"Wilder Gao","url":"http://wildergao.github.io"},"pages":[{"title":"关于 Wilder","date":"2018-09-16T07:22:27.000Z","updated":"2018-09-16T07:24:59.730Z","comments":true,"path":"about/index.html","permalink":"http://wildergao.github.io/about/index.html","excerpt":"","text":"姓名： 高键城 就读： 广东工业大学 学历： 本科在读 爱好： 羽毛球"}],"posts":[{"title":"每月一牛客———并发篇（2）","slug":"每月一牛客—并发篇(1)","date":"2018-09-16T01:13:57.000Z","updated":"2018-09-16T05:10:24.256Z","comments":true,"path":"2018/09/16/每月一牛客—并发篇(1)/","link":"","permalink":"http://wildergao.github.io/2018/09/16/每月一牛客—并发篇(1)/","excerpt":"","text":"SQL 题目2018.9.16 轮询调度和可抢占式调度 轮询调度的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始直到N（内部服务器的个数），然后重新开始循环。只有在当前任务主动放弃CPU控制权的情况下（比如任务挂起），才允许其它任务（包括高优先级的任务）控制CPU。它的优点是简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度，但不利于后面的请求及时得到响应。 抢占式调度允许高优先级的任务打断当前执行的任务，抢占CPU的控制权。这有利于后面的高优先级任务也能及时得到响应。但实现相对比较复杂且可能出现低优先级的任务长期得不到调度。 产生死锁的主要原因 系统资源不足 进程运行推进的顺序不合适 资源分配不当等 产生死锁的四个必要条件 互斥条件：一个资源每次只能被一个进程使用 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不可剥夺条件：进程已经获得的资源，在未使用完之前不能强行剥夺 循环等待条件：若干个进程之间形成一条头尾相接的循环等待资源关系 同步机制应该遵循的准则 空闲让进：当无进程处于进阶区时，表明临街资源处于空闲状态，允许一个请求进入临界区的进程立即进入临界区，以有效利用临界资源 忙则等待：当已有进程处于临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问 有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入死等状态 让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态","categories":[],"tags":[{"name":"刷题之路","slug":"刷题之路","permalink":"http://wildergao.github.io/tags/刷题之路/"}]},{"title":"并发编程总结五","slug":"并发编程总结五","date":"2018-09-12T08:17:18.000Z","updated":"2018-09-16T11:16:46.032Z","comments":true,"path":"2018/09/12/并发编程总结五/","link":"","permalink":"http://wildergao.github.io/2018/09/12/并发编程总结五/","excerpt":"","text":"并发编程总结五1、现在有线程T1、T2和T3。你如何确保T2线程在T1之后执行，并且T3线程在T2之后执行？ 这个问题主要是考察 join( ) 方法的应用，如果一个线程A执行了 thread.join() 语句，其含义是：当前线程A等待 thread 线程终止之后才从 thread.join() 返回。也就是说，当线程A执行了线程thread的 join 方法时，会先执行线程thread中的内容，等待从join方法返回之后，才会继续执行线程A方法剩下的内容。 12345678910111213141516171819202122232425262728 public class JoinLearn&#123; static class MyThread implements Runnable&#123; private Thread thread; public MyThread(Thread thread)&#123; this.thread = thread; &#125; @Override public void run() &#123; try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"正在运行......\"); &#125; &#125; public static void main(String[] args)&#123; Thread previous = Thread.currentThread(); Thread t1 = new Thread(new MyThread(previous), String.valueOf(1)); t1.start(); Thread t2 = new Thread(new MyThread(t1), String.valueOf(2)); t2.start(); Thread t3 = new Thread(new MyThread(t2), String.valueOf(3)); t3.start(); &#125;&#125; 2、Java 中新的 Lock 接口相对于同步代码块（synchronized block）有什么优势？ Lock接口提供了与synchronized类似的同步功能，只是在使用时需要显示地获取锁和释放锁 拥有了获取锁与释放锁的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。Lock多了锁投票，定时锁等候和中断锁等候等特性。 有这么一种情况，线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定。如果使用synchronized ，如果A不释放，B将会一直等待下去，而且B的等待不可以被中断。如果使用了 ReentrantLock ，如果A不释放，可以使B在等待了足够长的时间以后中断等待，而干别的事情。 接下来我们来说一下两者的用法： synchronized 可以锁定一个方法，也可以锁定一个对象，synchronized不需要自己定义获取锁和释放锁，这些都是隐式的。一旦线程A获取到锁之后，就只有线程A可以访问synchronized修饰的这个部分，只有等到线程A释放锁之后，其他线程才有访问的机会。 12345678910111213141516171819public class Sync implements Runnable&#123; private Data data = new Data(); @Override public synchronized void run() &#123; int tmp = data.getmVal(); ++tmp; data.setmVal(tmp); System.out.println(Thread.currentThread().getName()+\"|\"+data.getmVal()); &#125; public static void main(String[] args) &#123; Sync myThread = new Sync(); for (int i = 0; i &lt; 5; i++) &#123; Thread thread = new Thread(myThread); thread.start(); &#125; &#125;&#125; 运行结果为： 12345Thread-0|1Thread-1|2Thread-2|3Thread-3|4Thread-4|5 如果不使用synchronized修饰时，可能会产生如下结果： 12345Thread-0|2Thread-1|2Thread-2|3Thread-4|4Thread-3|5 Lock 由于需要自己手动获取锁和释放锁，当代码出现异常时，有可能因为下面的代码执行不到导致锁无法释放，因此要把释放锁放在finally中，我们同样适用上面synchronized的例子： 12345678910111213141516171819202122232425public class LockLearn implements Runnable&#123; Lock lock = new ReentrantLock(); Data data = new Data(); @Override public void run() &#123; lock.lock(); try &#123; int tmp = data.getmVal(); ++tmp; data.setmVal(tmp); System.out.println(Thread.currentThread().getName()+\"|\"+tmp); &#125;finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; LockLearn lock = new LockLearn(); for (int i = 0; i &lt; 5; i++) &#123; Thread thread = new Thread(lock); thread.start(); &#125; &#125;&#125; 3、Java 中 wait 和 sleep 方法有什么区别？ 根据我的理解以及查阅其它博客，大致总结一下 wait 和 sleep 的区别： sleep 让当前线程进入停滞状态（即阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。 在一个synchronized块中调用 sleep 方法时，线程虽然休眠但是不会释放锁。 在sleep 休眠时间满之后，该线程并不一定会立即执行，这是因为其他线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。 wait wait 方法不是线程中的方法，这个方法属于 Object 类；当一个线程执行 wait 方法时，它就进入到一个和该对象相关的等待池中，同时会释放锁。 wait 使用 notify 或者 notifyAll 或者指定的睡眠时间来唤醒当前等待池中的线程 wait 必须放在 synchronized block 中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。 4、如何在 Java 中实现一个阻塞队列？ 阻塞队列和普通队列的区别就是，当队列中没有元素的时候，调用出队方法的线程将会进入等待状态，直到队列中存在元素时线程会再次被唤醒；当队列已满的时候，调用入队方法的线程将会进入等待状态，直到有线程从队列中出队时该线程才会被唤醒。 我们使用 wait 和 notifyAll 方法来实现一个基本的阻塞队列 12345678910111213141516171819202122232425262728293031323334public class BlockingQueue &#123; private List queue = new LinkedList(); /** * 初始化队列大小 */ private int limit = 10; public BlockingQueue(int limit)&#123; this.limit = limit; &#125; public synchronized void enqueue(Object item) throws InterruptedException &#123; while (this.queue.size() == limit)&#123; //说明队列已满 wait(); &#125; if (this.queue.size() == 0)&#123; notifyAll(); &#125; this.queue.add(item); &#125; public synchronized Object dequeue() throws InterruptedException &#123; //队列为空不能出队 while (this.queue.size() == 0)&#123; wait(); &#125; if (this.queue.size() == this.limit)&#123; notifyAll(); &#125; return this.queue.remove(0); &#125;&#125; 5、写一段死锁代码。 说来就来，上死锁代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class DeadLockDemo &#123; private static String A = \"A\"; private static String B = \"B\"; public static void main(String[] args) &#123; new DeadLockDemo().deadLock(); &#125; private void deadLock()&#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (A)&#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (B)&#123; System.out.println(\"1\"); &#125; &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (B)&#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (A)&#123; System.out.println(\"2\"); &#125; &#125; &#125; &#125;); t1.start(); t2.start(); &#125;&#125; 从代码上可以看出，线程t1拿到了代码块A的锁，t2拿到了代码块B的锁，后来t1想拿到B的锁，t2想拿到A的锁，但是两条线程都不会释放锁，所以两者都陷入了等待状态，变成了死锁。 6、 既然 start() 方法会调用 run() 方法，为什么我们调用 start() 方法，而不直接调用 run() 方法？ start( )：他的作用是启动一个新线程，新线程会执行响应的 run( ) 方法，start( ) 不能被重复调用 run( )： run( ) 就和普通的成员方法一样，可以被重复调用。单独调用run( )的话，会在当前线程中执行run( )，而不会启动新的线程。 1234567891011121314151617public class RunAndStartDemo implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\" is running\"); &#125; public static void main(String[] args) &#123; RunAndStartDemo demo = new RunAndStartDemo(); Thread thread = new Thread(demo); System.out.println(\"调用run()方法...\"); thread.run(); System.out.println(\"调用start()方法...\"); thread.start(); &#125;&#125; 运行结果为： 1234调用 run() 方法...main is running调用 start() 方法...Thread-0 is running 8. Java 中 volatile 关键字是什么？你如何使用它？它和 Java 中的同步方法有什么区别？ 自从 Java 5 中调整 volatile 关键字和 Java 内存模型后，有关 volatile 关键字的线程问题越来越常见。掌握 volatile变量在并发环境中如何确保可见性、有序性和一致性非常重要。","categories":[],"tags":[{"name":"并发","slug":"并发","permalink":"http://wildergao.github.io/tags/并发/"}]},{"title":"每月一牛客———数据库篇（2）","slug":"每月一牛客—数据库篇(2)","date":"2018-08-03T01:13:57.000Z","updated":"2018-09-16T04:34:56.946Z","comments":true,"path":"2018/08/03/每月一牛客—数据库篇(2)/","link":"","permalink":"http://wildergao.github.io/2018/08/03/每月一牛客—数据库篇(2)/","excerpt":"","text":"SQL 题目2018.8.1 数据库设计包括留个主要步骤： ① 需求分析 需求收集和分析，得到用数据字典描述的数据需求，用数据流图描述的处理需求。 ② 概念结构设计 对需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型（用E-R图表示）。 ③ 逻辑结构设计 将概念结构转换为某个DBMS所支持的数据模型（例如关系模型），并对其进行优化。 ④ 物理结构设计 为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）。 ⑤ 数据库实施 运用DBMS提供的数据语言（例如SQL）及其宿主语言（例如C），根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。 ⑥ 数据库运行和维护 数据库应用系统数据库经过试运行后即可投入正式运行。在数据库系统运行过程中必须不断地对其进行评价、调整与修改。 数据库中有可能存在不一样的数据，造成数据不一致的原因主要有： 数据冗余 如果数据库中存在冗余数据，比如两张表中都存储了用户的地址，在用户的地址发生改变时，如果只更新了一张表中的数据，那么这两张表中就有了不一致的数据。 并发控制不当 比如某个订票系统中，两个用户在同一时间订同一张票，如果并发控制不当，可能会导致一张票被两个用户预订的情况。当然这也与元数据的设计有关。 故障和错误 如果软硬件发生故障造成数据丢失等情况，也可能引起数据不一致的情况。因此我们需要提供数据库维护和数据恢复的一些措施。 数据库的三级模式结构：模式、内模式、外模式 模式：模式也成为逻辑模式或概念模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个模式，模式位于三级结构的中间层 外模式：外模式也称用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据试图，是与某一应用有关的数据的逻辑表示。外模式是模式的子集，一个数据库可以有多个外模式 内模式：内模式也叫存储模式，一个数据库只有一个内模式，它是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式 2018.8.3 SQL语言可以直接以命令方式交互使用，也可以嵌入到程序设计语言中以程序方式使用 层次型、网状型和关系型数据库划分原则是：数据之间的联系 视图设计包括以下四种： 自顶向下：先全局框架，然后逐步细化 自底向上：先局部概念结构，再集成为全局结构 有里向外：先核心结构，再向外扩张 混合策略：1与2相结合，先自顶向下设计一个概念结构的框架，再自底向上为框架设计局部概念结构 tablespace（表空间）和 datafile 的关系 一个tablespace可以有一个或多个datafile 每个datafile只能在一个tablespace内，tablespace是逻辑上的概念,datafile则在物理上储存了数据库的种种对象。 table 中的数据，通过hash算法分布在tables 中的各个datafile 中 2018.8.6 数据库系统与文件系统的主要区别是：文件系统不能解决数据冗余和数据独立性问题，而数据库系统可以解决 触发器（trigger）是SQL server 提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作（ insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等。不会触发触发器的包括 SELECT、TRUNCATE、WRITETEXT、UPDATETEXT。 关系型数据库规范化是为解决关系数据库中 插入、删除和数据冗余 问题而引入的 为保证多用户环境中数据的完整性和一致性，DBMS采取的控制称为 并发控制 2018.8.8 当将局部的E-R图集成为全局E-R图时，可能存在3类冲突 属性冲突：包括类型、取值范围、取值单位的冲突； 结构冲突：例如同一对象在一个局部E-R图中作为实体，而在另一个局部E-R图中作为属性，同一实体在不同的E-R图中的属性个数和类型不同等； 命名冲突：体类型名、联系类型名之间异名同义，或同名异义等 2018.8.10 关系模型：数据表中的每一行代表的就是一个元组，每一列代表的就是一个属性，每一行数据的顺序是无关紧要的，而每一列的数据顺序则是必要的，假如顺序可以随意修改，那么将会出现数据混乱的情况。 两个关系的差运算，比如关系 R 和 S ，那么对 R 和 S 进行差运算则是找出 R 中存在的而 S 中不存在的元组 2018.8.22 数据库系统包括数据库，数据库管理系统，应用系统，数据库管理员 所以数据库系统是个大的概念 数据库是专门从数据的集合 数据库管理系统是由管理员操作管理数据库的查询、更新、删除等操作的 数据库应用系统用来操作数据库的。 数据库是长期存储在计算机内的有组织、可共享的大量的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。联系：数据库系统（DBS）中的“系统”是指能够提供一系列数据库相关服务组件的有机结合体。它应该包括：数据库（DB）、数据库管理系统（DBMS）（以及开发工具）、应用系统、数据库管理员（DBA）和用户构成。所以联系就是DBS包括DBMS和DB","categories":[],"tags":[{"name":"刷题之路","slug":"刷题之路","permalink":"http://wildergao.github.io/tags/刷题之路/"}]},{"title":"每日一牛客————数据库篇(2)","slug":"每日一牛客—数据库篇(2)","date":"2018-08-01T00:51:16.000Z","updated":"2018-09-16T04:34:49.370Z","comments":true,"path":"2018/08/01/每日一牛客—数据库篇(2)/","link":"","permalink":"http://wildergao.github.io/2018/08/01/每日一牛客—数据库篇(2)/","excerpt":"","text":"数据库篇 -","categories":[],"tags":[{"name":"刷题之路","slug":"刷题之路","permalink":"http://wildergao.github.io/tags/刷题之路/"}]},{"title":"每月一牛客-Java篇(2)","slug":"每月一牛客—Java篇(2)","date":"2018-08-01T00:08:04.000Z","updated":"2018-08-31T07:44:18.000Z","comments":true,"path":"2018/08/01/每月一牛客—Java篇(2)/","link":"","permalink":"http://wildergao.github.io/2018/08/01/每月一牛客—Java篇(2)/","excerpt":"Java 题目2018.8.1 通过HttpServletRequest.getParameter获取的参数由客户端浏览器和Web容器配置共同决定编码 方法的重写两同两小一大原则： 方法名相同，参数类型相同 子类返回类型小于等于父类方法返回类型 子类抛出异常小于等于父类方法抛出异常 子类访问权限大于等于父类方法访问权限","text":"Java 题目2018.8.1 通过HttpServletRequest.getParameter获取的参数由客户端浏览器和Web容器配置共同决定编码 方法的重写两同两小一大原则： 方法名相同，参数类型相同 子类返回类型小于等于父类方法返回类型 子类抛出异常小于等于父类方法抛出异常 子类访问权限大于等于父类方法访问权限 2018.8.2 ArrayList 的构造函数总共有三个： ArrayList() 构造一个初始容量为10的空列表 ArrayList(Collection&lt;? extends E&gt; c)构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排 ArrayList(int initialCapacity)构造一个具有指定初始容量的空列表。 DBMS：数据库管理系统（Database Management System）是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库。DBMS对数据库的保护通过4个方面来实现： 数据库的恢复 数据库的并发控制 数据库的完整性控制 数据库的安全性控制 DBMS中实现事务持久性的子系统是恢复管理子系统。可以这么理解：要想事务具有持久性，就得在事务出错时及时恢复 包装类的 “==” 运算在不遇到算术运算的情况下不会自动拆箱 包装类的 equals() 方法不处理数据转型 Servlet的生命周期一般可以用三个方法来表示： init()：仅执行一次，负责在装载Servlet时初始化Servlet对象 service() ：核心方法，一般HttpServlet中会有get,post两种处理方式。在调用doGet和doPost方法时会构造servletRequest和servletResponse请求和响应对象作为参数。 destory()：在停止并且卸载Servlet时执行，负责释放资源 初始化阶段：Servlet启动，会读取配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，将ServletConfig作为参数来调用init()方法。所以选ACD。B是在调用service方法时才构造的 2018.8.3 1234567byte b1=1,b2=2,b3,b6,b8;final byte b4=4,b5=6,b7;b3=(b1+b2); /*语句1*/b6=b4+b5; /*语句2*/b8=(b1+b4); /*语句3*/b7=(b2+b5); /*语句4*/System.out.println(b3+b6); ————知识点———— Java表达式转型规则由低到高转换： 1、所有的byte,short,char型的值将被提升为int型； 2、如果有一个操作数是long型，计算结果是long型； 3、如果有一个操作数是float型，计算结果是float型； 4、如果有一个操作数是double型，计算结果是double型； 5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。 ————–解析————– 语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int； 语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，所以和的类型视左边变量类型而定，即b6可以是任意数值类型； 语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4); 语句4错误：b7=(b2+b5); 同上。同时注意b7是final修饰，即只可赋值一次，便不可再改变。 2018.8.4 接口 只能用 public 和 abstract 修饰。only public &amp; abstract are permitted 。 内部接口 only public, protected, private, abstract &amp; static are permitted full GC触发的条件除直接调用System.gc外，触发Full GC执行的情况有如下四种。 旧生代空间不足旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。 Permanet Generation空间满PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。 CMS GC时出现promotion failed和concurrent mode failure对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。应对措施为：增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java-Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。 都是Throwable的子类： 1.Exception（异常）:是程序本身可以处理的异常。 2.Error（错误）: 是程序无法处理的错误。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，一般不需要程序处理。 3.检查异常（编译器要求必须处置的异常） ： 除了Error，RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。 4.非检查异常(编译器不要求处置的异常): 包括运行时异常（RuntimeException与其子类）和错误（Error）。 2018.8.6 几种数组复制的方法：（1）for循环逐一复制；（2）System.arraycopy ；（3）Array.copyOf；（4）使用clone方法 效率对比：System.arraycopy &gt; Array.copyOf &gt; 使用 clone 方法 &gt; for 循环逐一复制 System.arraycopy 方法调用的是本地native方法，效率最高 Array.copyOf 源码中调用的是 System.arraycopy 方法，自然效率低于前者 2018.8.7 finally 语句的有关说法 不管 catch 是否异常，finally 语句块都是要被执行的 在 try 语句块或 catch 语句块中执行到 System.exit(0) 直接退出程序 finally 块中的 return 语句会覆盖 try 块中的 return 返回 finally 语句块在 catch 语句块的 return 语句之前执行 下面程序的运行结果 12345678910111213public static void main(String args[]) &#123; Thread t=new Thread()&#123; public void run()&#123; dianping(); &#125; &#125;; t.run(); System.out.print(\"dazhong\"); &#125; static void dianping()&#123; System.out.print(\"dianping\");&#125; 运行结果为：dianpingdazhong 因为现在只是创建了线程并没有调用 start( ) ，只是声明了线程，所以说是按照顺序执行 2018.8.10 关于类的一些叙述 类不可以多继承但是可以多实现 抽象类和接口都不可以定义成员变量，但是他们可以定义静态成员变量，接口的静态成员变量需要用 public static final 进行修饰 抽象类和接口都不能被实例化 Java 异常处理的叙述 final 可以用来声明属性和方法，分别表示属性的不可变和方法的不可重写 throws 是用来声明一个成员方法可能抛出的各种非运行异常情况 throw 是用来明确地抛出一个异常情况 2018.8.13 JSP 内置对象及方法 request对象： 客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。 response对象：response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。 session对象：session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例. out对象：out对象是JspWriter类的实例,是向客户端输出内容常用的对象 page对象：page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例 application对象：application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。 exception对象：exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象 pageContext对象：pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。 config对象：config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象） 关于JDK中的一些工具 javac.exe 是编译 .java 文件 java.exe 是执行编译好的 .class 文件 javadoc.exe 是生成 java 说明文档 jdb.exe 是 java 调试器 javaprof.exe 是剖析工具 关于计算机的编码 了解ANSI和ASCII、Unicode 和 UTF-8的区别 2018.8.14 Java 提供的事件处理模型是一种人机交互模型，它有三个基本要素： 事件源：即事件发生的场所，就是指各个组件，如按钮等，点击按钮就是组件上发生的一个事件； 事件：事件封装了组件上发生的事情，比如按钮单击、按钮松开等等； 事件监听器：负责监听事件源上发生的特定类型的事件，当事件到来时还必须负责处理相应的事件 会话跟踪技术描述： Cookie 是 Web 服务器发送给客户端的一小段信息，客户端请求时，可以读取该信息发送到服务器端 关闭浏览器意味着临时会话ID丢失，但所有与原会话关联的会话数据仍保留在服务器上，直至会话过期 在禁用cookie时可以使用URL重写技术跟踪会话 URL重写技术跟踪session（1） URL重写技术跟踪session（2） 隐藏域在页面中对于用户（浏览器）是不可见的，在表单中插入隐藏域的目的在于收集或发送信息，以利于被处理表单的程序所使用。浏览者单击发送按钮发送表单的时候，隐藏域的信息也被一起发送到服务器。 2018.8.19 方法重载和重写的描述 方法重载：1、必须是同一个类；2、方法名一样；3、参数类型不一样或参数数量不一样 方法重写：1、方法名相同，参数类型相同；2、子类返回类型小于等于父类方法返回类型；3、子类抛出异常小于等于父类方法抛出的异常；4、子类访问权限大于等于父类方法访问权限 2018.8.31 对 final 关键字的说法 final 是 java 中的修饰符，可以修饰类、方法和属性，但不能修饰接口和抽象类，因为抽象类和接口一般都是要被继承的，被final修饰后就不能被继承了 被 final 修饰的方法不能被重写，但是可以被重载 final 修饰的类不能被继承 final 修饰的变量就是一个常量了，因此不能修改常量的值 java 中的package 定义在一个package中的类可以不经过import而直接相互引用 为了更好地组织类，Java提供了包机制。包是类的容器，用于分隔类名空间。如果没有指定包名，所有的示例都属于一个默认的无名包。Java中的包一般均包含相关的类，java是跨平台的，所以java中的包和操作系统没有任何关系，java的包是用来组织文件的一种虚拟文件系统","categories":[],"tags":[{"name":"刷题之路","slug":"刷题之路","permalink":"http://wildergao.github.io/tags/刷题之路/"}]},{"title":"每月一牛客——数据库篇(1)","slug":"每月一牛客—数据库篇(1)","date":"2018-07-24T03:12:37.000Z","updated":"2018-08-03T01:16:58.000Z","comments":true,"path":"2018/07/24/每月一牛客—数据库篇(1)/","link":"","permalink":"http://wildergao.github.io/2018/07/24/每月一牛客—数据库篇(1)/","excerpt":"Sql 题目2018-7-24 数据库系统的特点 共享性：因为数据是面向整体的，所以数据可以被多个用户、多个应用程序共享使用，可以大大减少数据冗余，节约存储空间，避免数据之间的不相容性与不一致性。 独立性：数据独立性包括数据的物理独立性和逻辑独立性 物理独立性：指数据在磁盘上的数据库中如何存储是由DBMS管理的，用户程序不需要了解，应用程序要处理的知识数据的逻辑结构，这样一来当数据的物理存储结构改变时，用户的程序不用改变。 逻辑独立性：指用户的应用程序与数据库的逻辑结构是相互独立的，也就是说，数据的逻辑结构改变了，用户程序也可以不改变。 结构化：数据库系统实现了整体数据的结构化，这是数据库最主要的特征之一。整体结构化是指在数据库中的数据不再仅针对某个应用，而是面向全组织；不仅数据内部是结构化，而且整体式结构化，数据之间有联系。","text":"Sql 题目2018-7-24 数据库系统的特点 共享性：因为数据是面向整体的，所以数据可以被多个用户、多个应用程序共享使用，可以大大减少数据冗余，节约存储空间，避免数据之间的不相容性与不一致性。 独立性：数据独立性包括数据的物理独立性和逻辑独立性 物理独立性：指数据在磁盘上的数据库中如何存储是由DBMS管理的，用户程序不需要了解，应用程序要处理的知识数据的逻辑结构，这样一来当数据的物理存储结构改变时，用户的程序不用改变。 逻辑独立性：指用户的应用程序与数据库的逻辑结构是相互独立的，也就是说，数据的逻辑结构改变了，用户程序也可以不改变。 结构化：数据库系统实现了整体数据的结构化，这是数据库最主要的特征之一。整体结构化是指在数据库中的数据不再仅针对某个应用，而是面向全组织；不仅数据内部是结构化，而且整体式结构化，数据之间有联系。 SQL语言具有两种使用方式，分别是交互式SQL和嵌入式SQL 交互式SQL：在独立使用SQL语言进行数据库操作时，其使用方式称为交互式SQL。 嵌入式SQL：当一个程序既要访问数据库，又要处理数据时，把SQL语言嵌入程序设计语言（也叫宿主语言）中，将SQL语言访问数据库的功能和宿主语言的数据处理能力相结合，是目前解决该问题的最有效途径。这样使用的SQL称为嵌入式SQL。 SQL语言中的操作命令 DML（data manipulation language）是数据库操纵语言：他们是 UPDATE、INSERT、DELETE，这4条命令是用来对数据库里的数据进行操作的语言。 DCL（data control language）是数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括GRANT、DENY、REVOKE等语句。 GRANT 是授权语句 1234USE database;GRANT CREATE TABLE TO user1;GO---- 授予用户user1对database数据库创建表的权限 DENY 是禁止某一权限的语句 123-----禁止member用户对数据表person的更新权限：DENY UPDATE ON person TO member CASCADE; REVOKE是收回用户权限的语句 123-----收回用户member对person表的删除权限：REVOKE DELETE ON personFROM member DQL：数据查询语言 DQL基本结构是由SELECT子句、FROM子句、WHERE子句组成的查询块 DDL：数据定义语言 用来创建数据库中的各种对象——表、视图、索引、同义词、聚簇等： 1CREATE TABLE/VIEW/INDEX/SYN/CLUSTER ​ 数据库中的参照完整性 ​ 比如我们有两个表，一个表(department)存放的是部门的信息，例如部门id，部门名称等；另一个表是员工表(staff)，员工表里面肯定要存放每个员工所在的部门。那问题来了，如果我们这个时候删除了部门表中的某条记录，在staff表中会发生什么？ 参照完整性：保证在一个关系中给定属性集上的取值也在另一个关系的特定属性集的取值中出现。这种情况称为参照完整性(referential integrity)。 ​ 也就是我们所说的外键（Foreign Key），当将外键指明为cascade时，则说明department表更新时对应的staff表也会进行相应的更新。当删除了部门表中的某一个字段时，staff表中对应的员工信息也会被删除。foreign key子句指明除了cascade以外的其他动作，如果约束被违反，可将参考与置为null(用set null代替 cascade)，或者置为默认值(set default)。 ​ 但是，一般来说，我们习惯的用法是，不允许删除。如果实在要删除，可以在被参照关系中加一个字段，来表明当前的记录被删除了，这样也方便日后查询等相关操作 数据库系统必须提供的数据控制功能：安全性、完整性、并发控制 mysql 的主从复制 ​ (1) master将数据改变记录到二进制日志(binary log)中,也即是配置文件log-bin指定的文件(这些记录叫做二进制日志事件，binary log events) ​ (2) slave将master的binary log events拷贝到它的中继日志(relay log) ​ (3) slave重做中继日志中的事件,将改变反映它自己的数据(数据重演) ​ 2018-7-25 事务的四大特性 隔离性：一个事务内部的操作及使用的数据对并发的其他事务的隔离的 持续性：事务一旦提交，对数据库的改变是永久的 原子性：事务中包括的所有操作要么都做，要么都不做 一致性：事务必须是使数据库从一个一致性状态变到另一个一致性状态 数据库三个模式两个映像 概念模式（conceptual schema）是数据库中全部数据的整体逻辑结构的描述。 外模式（external schema）是用户与数据库系统的接口，是用户用到的那部分数据的描述。 内模式（internal schema）是数据库在物理存储方面的描述，定义所有内部记录类型、索引和文件的组织方式，以及数据控制方面的细节。 模式／内模式映象存在于概念级和内部级之间，用于定义概念模式和内模式之间的对应性。 外模式／模式映象存在于外部级和概念级之间，用于定义外模式和概念模式之间的对应性。 关系模型是将数据间的关系看成二维表 12SELECT COUNT （ DISTINCT 学号）FROM 成绩 WHERE 分数＞ 60 可以看到两个关键字 COUNT 和 DISTINCT ，COUNT 是记录总数，DISTINCT 是选出不同的数据，所以COUNT 和 DISTINCT同时使用代表的就是计算出不同数据的数量。 数据表的水平分割和垂直分割 水平分割：根据一列或多列数据的值把数据行放到两个独立的表中 水平分割通常在下面的情况下使用。 •表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度。 •表中的数据本来就有独立性，例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。 •需要把数据存放到多个介质上。 ​ 水平分割会给应用增加复杂度，它通常在查询时需要多个表名，查询所有数据需要union操作。在许多数据库应用中，这种复杂性会超过它带来的优点，因为只要索引关键字不大，则在索引用于查询时，表中增加两到三倍数据量，查询时也就增加读一个索引层的磁盘次数。 垂直分割：把主码和一些列放到一个表，然后把主码和另外的列放到另一个表中 如果一个表中某些列常用，而另外一些列不常用，则可以采用垂直分割，另外垂直分割可以使得数据行变小，一个数据页就能存放更多的数据，在查询时就会减少I/O次数。其缺点是需要管理冗余列，查询所有数据需要join操作。 对表进行垂直分割用的运算是投影、进行水平分割用的运算是选择 2018-7-29 共享锁（S锁）又称读锁，读取操作创建的锁。其它用户可以并发读取数据，但任何事务都不能获取数据上的排它锁，直到已释放所有的共享锁。 若事务T对数据对象A加上S锁，则事务T只能读A；其它事务只能再对A加上S锁而不能加X锁，知道T释放A上的S锁。这就保证了其它事务可以读A，但在T释放A上的锁之前不能对A做任何修改。 排它锁（X锁）又称为写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。 数据库系统中的故障可以分为：事务故障、系统故障、介质故障 事务故障：某个事务在运行过程中由于种种原因未运行至正常终止点，事务故障的常见原因，输入数据有误运算溢出，违反了某些完整性限制发生锁死。事务故障可以通过运行日志进行恢复。 介质故障：指外存储设备故障，主要有磁盘损坏，磁头碰撞盘面，突然的强磁场干扰，数据传输部件出错，磁盘控制器出错等。这类故障将破坏数据库本身，影响到出故障前存储数据库的所有事务。 系统故障：由于某种原因造成整个系统的正常运行突然停止，致使所有正在运行的事务都以非正常方式终止。发生系统故障时，内存中数据库缓冲区的信息全部丢失，但存储在外部存储设备上的数据未受影响 。 运算的区分 关系运算包括：选择、投影、连接以及除法 集合运算是二目运算，包括并、差、交、广义笛卡尔积四种","categories":[],"tags":[{"name":"刷题之路","slug":"刷题之路","permalink":"http://wildergao.github.io/tags/刷题之路/"}]},{"title":"JVM学习笔记（二）","slug":"JVM学习笔记（二）","date":"2018-07-21T01:06:03.000Z","updated":"2018-07-21T02:33:48.000Z","comments":true,"path":"2018/07/21/JVM学习笔记（二）/","link":"","permalink":"http://wildergao.github.io/2018/07/21/JVM学习笔记（二）/","excerpt":"","text":"JVM：Class文件的结构不看不知道，一看吓一跳，一个class文件里面居然包含了这么多东西。让我们揭开 class 文件的面纱，来看看 class 文件的结构吧。 一、简介Class 文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，使得整个Class文件中存储的内容几乎全都是程序运行的必要数据，没有空隙存在。 当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。 Class文件采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。 无符号数属于基本的数据类型，以u1、u2、u4、u8 来分别代表1个字节、2个字节、4个字节和8个字节的无符号数。无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表的习惯地以&quot;_info&quot;结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。 类型 名称 数量 u4 magic 1 u2 minor_version 1 u2 major_version 1 u2 constant_pool_count 1 cp_info constant_pool constant_pool_count -1 u2 access_flags 1 u2 this_class 1 u2 super_class 1 u2 interfaces_count 1 u2 interfaces interfaces_count u2 fields_count 1 field_info fields fields_count u2 methods_count 1 method_info methods methods_count u2 attribute_count 1 attribute_info attributes attributes_count 无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容器计数器加若干个连续的数据项的形式。在Class文件中，无论是顺序还是数量都是被严格限制的，哪个字节代表什么意义，长度是多少，先后顺序如何，都不允许改变。 二、魔数 每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否是一个能被虚拟机接受的Class文件。Class文件的魔数值为：0xCAFEBABY（我一直这么记：咖啡宝贝）。 三、Class 文件的版本紧接着魔数的4个字节存储的是Class文件的版本号：前两个字节表示次版本号，后两个字节是主版本号。 例如，JDK1.1能支持版本号为45.0~45.65535的Class文件，而JDK1.2则能支持45.0~46.65535的Class文件。高版本的JDK可以向下兼容以前版本的Class文件，但不能运行以后的Class文件，即使文件格式并未发生任何变化，虚拟机也会拒绝执行超过其版本号的Class文件。 四、常量池紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。 （一）常量池大小由于常量池的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。值得注意的是，常量池的容量计数是从1而不是0开始的。 假如一个Class文件的表示常量池容量的字段值为0x0016，即十进制的22，这就代表常量池有21项常量，索引值范围为1~21。这里空出了索引为0的情况，这样做的目的就在于满足后面某些指向常量池的索引值的数据在待定的情况下需要表达“不引用任何常量池项目”的含义。 Class文件中只有常量池的容量计数是从1开始的，对于其他集合类型，都是从0开始的。 （二）常量池存放类型常量池主要存放两大类常量：字面量和符号引用。 字面量比较接近于 Java 语言层面的常量概念，如文本字符串、声明为 final 的常量值等（这里想到一点类加载机制的知识，final修饰的常量在编译时就被加载到方法区中，而不是等到初始化之后才给这个常量赋值）。 符号引用则属于编译原理方面的概念，包括下面三大常量： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 Java代码在进行javac编译的时候，并不像C++那样有连接这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。 也就是说在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法被虚拟机直接使用。当虚拟机运行的时候，需要从常量池中获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。 （三）常量池具体类型常量池中每一项常量都是一个表，在JDK1.7中，一共有14中结构各不相同的表结构。 这14种表都有一个共同的特点，就是表开始的第一位是一个u1类型的标志位（tag）,代表当前这个常量属于那种常量类型。 下面是这14中常量的具体含义（其实看英文都大致可以看得出来）： 常量池中数据项类型 类型标志 类型描述 CONSTANT_Utf8_info 1 UTF-8编码的Unicode字符串 CONSTANT_Integer_info 3 int类型字面值 CONSTANT_Float_info 4 float类型字面值 CONSTANT_Long_info 5 long类型字面值 CONSTANT_Double_info 6 double类型字面值 CONSTANT_Class_info 7 对一个类或接口的符号引用 CONSTANT_String_info 8 String类型字面值 CONSTANT_Fieldref_info 9 对一个字段的符号引用 CONSTANT_Methodref_info 10 对一个类中声明的方法的符号引用 CONSTANT_InterfaceMethodref_info 11 对一个接口中声明的方法的符号引用 CONSTANT_NameAndType_info 12 对一个字段或方法的部分符号引用 CONSTANT_MethodHandle_info 15 标识方法句柄 CONSTANT_MethodType_info 16 标识方法类型 CONSTANT_InvokeDynamic_info 18 表示一个动态方法调用点 我们来看一个例子： 我们可以看到前面四个字节（u4）就是魔数 CAFEBABE","categories":[],"tags":[{"name":"JVM学习笔记","slug":"JVM学习笔记","permalink":"http://wildergao.github.io/tags/JVM学习笔记/"}]},{"title":"每月一牛客—Java篇(1)","slug":"每月一牛客—Java篇(1)","date":"2018-07-14T23:42:51.000Z","updated":"2018-08-03T01:16:10.000Z","comments":true,"path":"2018/07/15/每月一牛客—Java篇(1)/","link":"","permalink":"http://wildergao.github.io/2018/07/15/每月一牛客—Java篇(1)/","excerpt":"Java 题目2018.7.15 多个线程可同时操作一个数据，为了保证该数据的准确性，可将操作数据的部分改为 同步 同步：进程之间的关系不是相互排除临界资源的关系，而是相互依赖的关系。进一步说明就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。 异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。 异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。","text":"Java 题目2018.7.15 多个线程可同时操作一个数据，为了保证该数据的准确性，可将操作数据的部分改为 同步 同步：进程之间的关系不是相互排除临界资源的关系，而是相互依赖的关系。进一步说明就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。 异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。 异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。 JSP 四大作用区：page、request、session、application 存储在application对象中的属性可以被同一个WEB应用程序中所有的Servlet 和 Jsp 页面访问。（属性作用范围最大） 存储在session对象中的属性可以被属于同一个会话（浏览器打开直到关闭称为一次会话，且在此期间会话不失效）的所有Servlet 和 Jsp 页面访问 存储在request对象中的属性可以被属于同一个请求的所有Servlet和JSP页面访问（在有转发的情况下可以跨页面获取属性值），例如使用PageContext.forward和PageContext.include方法连接起来的多个Servlet和JSP页面。 存储在pageContext对象中的属性仅可以被当前JSP页面的当前响应过程中调用的各个组件访问，例如，正在响应当前请求的JSP页面和它调用的各个自定义标签类。 ServletConfig 接口默认是 GenericServlet 实现的（自己看源码结构吧） 关于JVM内存一些概念的叙述： 程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的 Java 方法执行在内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的 方法区用于存储JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是线程共享的（看到静态变量就要想到线程共享啊） 原则上讲，所有的对象都在堆内存上分配，是线程共享的 对象序列化： 要使流可以传输对象，则对象需要实现Serializeable接口，使用ObjectInputStream 和 ObjectOutputStream 便可以实现 使用 transient 修饰的变量不会被初始化 对象序列化的所属类需要实现Serializable 接口 线程安全的集合：vector，stack，hashtable，enumeration，除此之外均是非线程安全的类与接口 可以这么记忆：喂！SHE！ 喂是指 vector，S是指 stack， H是指 hashtable，E是指：Eenumeration 以下JSP代码定义了一个变量，输出这个变量的值： &lt;bean:define id=”stringBean” value=”helloWorld”/&gt; 1&lt;%=stringBean%&gt; 1&lt;bean:write name=\"stringBean\"/&gt; 12&lt;%String myBean=(String)pageContext.getAttribute(\"stringBean\",PageContext.PAGE_SCOPE);%&gt;&lt;%=myBean%&gt; 2018.7.17 管道（Pipe）通信的叙述 进程对管道进行读操作和写操作都可能被阻塞：当管道中没有信息的时候，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也会自动消失。 管道只支持具有亲缘关系的两个进程之间的通信，比如父进程和子进程 一个管道不可以实现双向传输，匿名管道只能直线单向传输，要想实现双向传输的话可以建立两个管道 管道随进程，进程在管道在，进程消失管道对应的端口也关闭，两个进程消失管道也对应消失 HashMap 和 HashTable 1234567891011//HashMap的源码public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable-----------------------------------//Hashtable的源码public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable----------------------------------很明显，都实现了Map接口 12345public V put(K key, V value) //HashMap的put方法，没有同步 public synchronized V put(K key, V value) //Hashtable的put方法//当然，Hashtable的其他方法，如get，size，remove等方法，//都加了synchronized关键词同步操作 12345678910//Hashtable的put方法有以下语句块，大伙看了都知道// Make sure the value is not nullif (value == null) &#123; throw new NullPointerException();&#125; //那么，我们再来看下HashMap的put方法中，有如下语句//调用某个方法直接把key为null，值为value的键值对插入进去。if (key == null) return putForNullKey(value); 12345678//以下是Hashtable的方法public synchronized boolean contains(Object value)public synchronized boolean containsKey(Object key)public boolean containsValue(Object value) //以下是HashMap中的方法，注意，没有contains方法public boolean containsKey(Object key)public boolean containsValue(Object value) Java 面向对象基础 java为单继承，多实现。可以实现多个接口。 接口允许定义成员，但必须是常量 。 抽象类和接口类的无法实例化，任何编译器中直接使用new会报错。 2018.7.18 Java Socket 获取IP地址 本地IP地址：getLocalAddress() 连接IP地址：getInetAddress() getReuseAddress() 测试是否启用 SO_REUSEADDR 关于 SO_REUSEADDR : 点我了解 Java 基本类型：如果不明确指定，整数型的默认的 int 类型，带小数的默认是 double 类型 Java 语言性特点 Java 致力于检查程序在编译和运行时的错误 Java 能运行虚拟机实现跨平台 Java 自己操作内存减少了内存出错的可能性 程序设计语言中，数组元素在内存中是一个接着一个线性存放的，通过第一个元素就能访问随后的元素，这样的数组称之为“真数组”。 实现了真数组为Java语言健壮性的特点之一。Java 实现了真数组，避免了覆盖数据的可能（而不是覆盖数据类型的可能） Sql 获取结果集的两种方式：Statement 和 PrepareStatement Statement 创建是不传参的 PrepareStatement 是需要传入 sql 语句的 JDK提供用于并发编程的同步器 Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。 CyclicBarrier 主要的方法就是一个：await()。await() 方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。 倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。 2018.7.20 | 作用域 | 当前类 | 同一包 | 子孙类 | 其他包 || :——– | :— | —- | —- | —- || public | √ | √ | √ | √ || protected | √ | √ | √ | || default | √ | √ | | || private | √ | | | | JDK8开始，接口中可以定义有方法体的方法，方法必须被default和static修饰。除此之外，其他方法都是抽象方法。 Java的语法是单继承，但是继承可以传递。其实B更准确一点是只能有一个直接父类。 继承用extends，实现用implements。先继承后实现。 类是class，接口是interface。 流媒体 技术的一种可以使音频、视频和其他多媒体信息在Internet 及 Internet 上以实时的，无需下载等待的方式进行播放的技术 关于 structs 框架 structs 可以进行文件上传 structs 基于 MVC 模式，MVC是模型、视图、控制器，是一种设计模式 structs 框架让流程结构更清晰 structs 需要很多 action 类，会增加文件数目 关于java Object 默认的基本方法 equals(Object obj) 指示某个其他对象是否与此对象“相等” Object 对象没有copy() 这个方法 wait() 导致当前线程的等待，直到其它线程调用此对象的notify() 方法或者 notifyAll() 方法 在 Web 开发中实现会话跟踪 ​ 会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。​ HTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面 之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。 隐藏表单域：，非常适合步需要大量数据存储的会话应用。 URL 重写:URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。 Cookie:一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值。 Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话 2018.7.21 类方法 在类方法中不可以用 this 来调用本类的类方法（将 this 理解为对象，而类方法属于类不属于对象，所以类方法前面不能加 this 指针） 在类方法中调用本类的类方法时可以直接调用 在类方法中可以调用实例方法 2018.7.22 面向对象的五大基本原则 单一职责原则（SRP）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看作是低耦合、高内聚在面向对象原则上的隐申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。 开放封闭原则（OCP）：软件实体应该是可扩展的，而不可修改的。也就是对外扩展开放，对内修改封闭的。 Liskov替换原则（LSP）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替代基类时，才能保证系统在运行期间识别子类，这是保证继承复用的基础。 依赖倒置原则（DIP）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 接口隔离原则（ISP）：使用多个小的专门接口，而不要使用一个大的总接口。 内部类实例化 12345678910111213public class Enclosingone &#123; //非静态内部类 public class InsideOne &#123;&#125; //静态内部类 public static class InsideTwo&#123;&#125;&#125; class Mytest02&#123; public static void main(String args [])&#123; Enclosingone.InsideOne obj1 = new Enclosingone().new InsideOne();//非静态内部类对象 Enclosingone.InsideTwo obj2 = new Enclosingone.InsideTwo();//静态内部类对象 &#125;&#125; 2018.7.23 有一个源代码，只包含import java.util.* ; 这一个import语句： 能访问 Java.util目录下的所有类，但不能访问 Java.util 子目录下的所有类，因为如果 Java.util 里面有个a类，Java.util.regex里面也有一个a类，我们若是要调用a类的方法或属性时，就不知道使用哪个a类 关于枚举类的知识 1234567891011121314151617181920enum AccountType&#123; SAVING, FIXED, CURRENT; private AccountType() &#123; System.out.println(“It is a account type”); &#125;&#125;class EnumOne&#123; public static void main(String[]args) &#123; System.out.println(AccountType.FIXED); &#125; // 输出结果为：It is a account type // It is a account type // It is a account type // FIXED&#125; 枚举类在后台实现时，实际上是转化为一个继承了 java.lang.Enum类的实体类，原先的枚举类型变成对应的实体类型。上述例子中 AccountType 将会转换成Class AccountType，并且会生成新的构造函数，假如原来有构造函数，则在此基础上添加两个参数，生成新的构造函数。所以上述例子的构造函数将变为： 1234pricate AccountType(String s, int i)&#123; super(s, i); System.out.println(“It is a account type”);&#125; 我们看到Enum 类的源码，这两个参数分别代表 枚举变量和名称 和 这个枚举变量在声明中的位置： 123456789101112131415/** * Sole constructor. Programmers cannot invoke this constructor. * It is for use by code emitted by the compiler in response to * enum type declarations. * * @param name - The name of this enum constant, which is the identifier * used to declare it. * @param ordinal - The ordinal of this enumeration constant (its position * in the enum declaration, where the initial constant is assigned * an ordinal of zero). */protected Enum(String name, int ordinal) &#123; this.name = name; this.ordinal = ordinal;&#125; 在这个类中，会添加若干个字段来代表具体的枚举类型： 123public static final AccountType SAVING ;public static final AccountType FIXED ;public static final AccountType CURRENT ; 而且还会添加一段 static 代码段： 1234567static &#123; SAVING = new AccountType(\"SAVING\", 0); FIXED = new AccountType(\"FIXED\", 0); CURRENT = new AccountType(\"CURRENT\", 0); $VALUES = new AccoutType[]&#123;SAVING, FIXED, CURRENT&#125;&#125; 以此来初始化枚举中的每个具体类型。（并将所有具体类型放到一个$VALUE数组中，以便用序号访问具体类型） 在初始化过程中new AccountType构造函数被调用了三次，所以Enum中定义的构造函数中的打印代码被执行了3遍。 以下代码的输出结果是 12345678910111213141516public class B&#123; public static B t1 = new B(); public static B t2 = new B(); &#123; System.out.println(\"构造块\"); &#125; static &#123; System.out.println(\"静态块\"); &#125; public static void main(String[] args) &#123; B t = new B(); &#125;&#125; 结果为：构造块 构造块 静态块 构造块 开始时JVM加载B.class，对所有的静态成员进行声明，t1 t2被初始化为默认值，为null，又因为t1 t2需要被显式初始化，所以对t1进行显式初始化，初始化代码块→构造函数（没有就是调用默认的构造函数），咦！静态代码块咋不初始化？因为在开始时已经对static部分进行了初始化，虽然只对static变量进行了初始化，但在初始化t1时也不会再执行static块了，因为JVM认为这是第二次加载类B了，所以static会在t1初始化时被忽略掉，所以直接初始化非static部分，也就是构造块部分（输出’’构造块’’）接着构造函数（无输出）。接着对t2进行初始化过程同t1相同（输出’构造块’），此时就对所有的static变量都完成了初始化，接着就执行static块部分（输出’静态块’），接着执行，main方法，同样也，new了对象，调用构造函数输出（’构造块’） 2018.7.25 使用Float创建的三种方法 123456//自动装箱拆箱方法Float f = 1.6f; //注意浮点数默认是double类型，所以 Float f = 1.6//两种构造方法Float f1 = new Float(1.6);Float f2 = new Float(1.6f);//Float 类有两种构造方式，分别是 Float(float f) 和 Float(double d) Servlet 和 CGI 的描述 对比一：当用户浏览器发出一个Http/CGI的请求，或者说调用一个CGI程序的时候，服务器端就要新启用一个进程 (而且是每次都要调用)，调用CGI程序越多(特别是访问量高的时候)，就要消耗系统越多的处理时间，只剩下越来越少的系统资源，对于用户来说，只能是漫长的等待服务器端的返回页面了，这对于电子商务激烈发展的今天来说，不能不说是一种技术上的遗憾。而Servlet充分发挥了服务器端的资源并高效的利用。每次调用Servlet时并不是新启用一个进程 **，而是在一个Web服务器的进程敏感词享和分离线程，而线程最大的好处在于可以共享一个数据源，使系统资源被有效利用。 对比二：传统的CGI程序，不具备平台无关性特征，系统环境发生变化，CGI程序就要瘫痪，而Servlet具备Java的平台无关性，在系统开发过程中保持了系统的可扩展性、高效性。 对比三：传统技术中，一般大都为二层的系统架构，即Web服务器+数据库服务器，导致网站访问量大的时候，无法克服CGI程序与数据库建立连接时速度慢的瓶颈，从而死机、数据库死锁现象频繁发生。而我们的Servlet有连接池的概念，它可以利用多线程的优点，在系统缓存中事先建立好若干与数据库的连接，到时候若想和数据库打交道可以随时跟系统”要”一个连接即可，反应速度可想而知。 方法重写的两同两小一大规则 方法名相同，参数类型相同 子类返回类型小于等于父类方法返回类型 子类抛出异常小于等于父类方法抛出异常 子类访问权限大于等于父类方法访问权限 2018.7.26 1234567891011121314151617181920212223242526272829class C &#123; C() &#123; System.out.print(\"C\"); &#125;&#125; class A &#123; C c = new C(); A() &#123; this(\"A\"); System.out.print(\"A\"); &#125; A(String s) &#123; System.out.print(s); &#125;&#125; class Test extends A &#123; Test() &#123; super(\"B\"); System.out.print(\"B\"); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; 初始化过程： （1）首先，初始化父类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； （2）然后，初始化子类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化； （3）其次，初始化父类中的普通成员变量和代码块，再执行父类的构造方法； （4）最后，初始化子类的普通成员变量和代码块，再执行子类的构造方法 所以可以看到，main方法运行的时候先找初始化A类的普通成员变量和代码块（父类和子类都没有静态成员变量和代码块），也就是运行了C c = new C( )。 之后初始化构造方法A(String B)，最后再打印出B，所以打印出“CBB” 可以把任何一种数据类型的变量赋给 Object 类型的变量 在 Java 中，constructor 必须与 class 同名，方法也可以与 class 同名 2018.7.27 Vector相当于一个线程安全的List HashMap是非线程安全的，其对应的线程安全类是HashTable Arraylist是非线程安全的，其对应的线程安全类是Vector StringBuffer是线程安全的，相当于一个线程安全的StringBuilder Properties实现了Map接口，是线程安全的 2018.7.28 Object 类的方法 静态内部类不可以直接访问外围类的非静态数据，而非静态内部类可以直接访问外围类的数据，包括私有数据。 2018.7.30 Java 异常机制 运行时异常： 都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 ​ 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。非运行时异常 （编译异常）： 是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。","categories":[],"tags":[{"name":"刷题之路","slug":"刷题之路","permalink":"http://wildergao.github.io/tags/刷题之路/"}]},{"title":"JVM学习笔记-GC（3）","slug":"JVM学习笔记-GC（3）","date":"2018-06-04T14:05:20.000Z","updated":"2018-06-04T15:08:26.000Z","comments":true,"path":"2018/06/04/JVM学习笔记-GC（3）/","link":"","permalink":"http://wildergao.github.io/2018/06/04/JVM学习笔记-GC（3）/","excerpt":"","text":"垃圾收集算法Java 语言的一大特点就是可以进行自动垃圾回收处理，而无需开发人员过于关注系统资源，例如内存资源的释放情况。 （一）标记 - 清除算法最基础的收集算法是 “ 标记 - 清除算法 ”，如同它的名字一样，算法分为 标记 和 清除 两个阶段： 首先标记出所有需要回收的对象 在标记完成后统一回收所有标记的对象 这种算法被称为最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足而进行改进而得到的。主要不足有两个： 一是效率问题，标记和清除两个过程的效率都不高 一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作。 （二）复制算法它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用光了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。复制算法的执行过程如图所示： 从图片可以看到，这种算法的代价是将内存缩小为原来的一半，未免会太高了点。 但是为什么商业虚拟机都会采取这种算法来回收新生代呢？经过研究发现，新生代的对象98%都是“朝生夕死”的，所以并不需要按照1：1的比例来划分内存空间，而是将内存划分为一块较大的 Eden 空间和两块较小的 Survivor 空间（分别是from空间和to空间），每次使用 Eden 和 from 空间。当回收时，将Eden 和 Survivor 中还存活着的对象一次性地复制到 to 空间，最后将 Eden 和 from 空间清理掉。 HotSpot虚拟机默认的Eden和Survivor的比例为 8 : 1，也就是每次只有10%的空间被浪费掉。 我们无法保证每次回收只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（老年代）进行分配担保。 复制算法的主要不足： 复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况。所以，老年代一般不能直接选用这种算法。 （三）标记 - 整理算法标记过程仍然与“标记 - 清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存： (四) 分代收集算法","categories":[],"tags":[{"name":"JVM学习笔记","slug":"JVM学习笔记","permalink":"http://wildergao.github.io/tags/JVM学习笔记/"}]},{"title":"JVM学习笔记:GC(2)","slug":"JVM学习笔记-GC（2）","date":"2018-05-28T17:12:03.000Z","updated":"2018-05-30T06:18:40.000Z","comments":true,"path":"2018/05/29/JVM学习笔记-GC（2）/","link":"","permalink":"http://wildergao.github.io/2018/05/29/JVM学习笔记-GC（2）/","excerpt":"","text":"​ 今天我们来看看 JVM 如何判断对象是否可以被回收…… 对象已死吗 在堆里存放着几乎所有的实例对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”。接下来介绍几种算法。 一、引用计数算法引用计数算法的流程是这样子的：给对象添加一个引用计数器，每次当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为 0 的对象就是不可能再被使用的。但是 JVM 并没有使用这种算法来管理内存，最主要的原因就是它很难解决对象之间相互循环引用的问题。我们来看一段代码： 123456789101112131415public class Wilder&#123; public Object instance = null; public static void testGC()&#123; Wilder wilderA = new Wilder(); Wilder wilderB = new Wilder(); wilderA.instance = wilderB; wilderB.instance = wilderA; wilderA = null; wilderB = null; System.gc(); &#125;&#125; 如果JVM使用的是引用计数算法：最后两个对象都指向了 null ， 但是由于两者相互引用，所以两者的引用计数器不为 0 ，所以即时 GC 了两个对象都不会被回收。 但是从结果的 GC 日志上来看，这两个对象被 JVM 回收了，所以说使用的并不是这种算法。 二、可达性分析算法这个算法的基本思想就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（也就是GC Roots到这个对象不可达），则证明此对象是不可用的。 从图中看出 Object_E、Object_F、Object_G 从GC Root 搜索到，所以 JVM 认为这些对象不可用了，将会把这些对象回收。 在 Java 语言中，可作为 GC Roots 的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中 JNI （一般说的 Native 方法）引用的对象 三、生存还是死亡对象被宣告死亡要经历两个阶段： 第一个阶段就是可达性分析，判断对象是否具有有效引用 第二个阶段就是判断对象是否有必要执行 finalize（）方法。当对象没有覆盖finalize（）方法或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况称为“没有必要执行”，就是对象已经没有任何机会完成救赎。如果认为这个对象有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程区执行它。 12345678910111213141516171819202122232425262728293031public class FinalizeEscapeGc &#123; private static FinalizeEscapeGc SAVE_HOOK = null; public void isAlive()&#123; System.out.println(\"yes, i am still alive\"); &#125; @Override protected void finalize() throws Throwable&#123; super.finalize(); System.out.println(\"finalize method executed!\"); FinalizeEscapeGc.SAVE_HOOK = this; &#125; public static void main(String[] args) throws InterruptedException &#123; SAVE_HOOK = new FinalizeEscapeGc(); SAVE_HOOK = null; System.gc(); Thread.sleep(500); if(SAVE_HOOK!= null)&#123; SAVE_HOOK.isAlive(); &#125;else&#123; System.out.println(\"no ,i am dead \"); &#125; SAVE_HOOK = null; System.gc(); Thread.sleep(500); if(SAVE_HOOK!= null)&#123; SAVE_HOOK.isAlive(); &#125;else&#123; System.out.println(\"no ,i am dead \"); &#125; &#125;&#125; 程序运行的结果： 123finalize method executed!yes, i am still aliveno ,i am dead 从结果我们可以看到，SAVE_HOOK 对象确实在被 GC 回收之前调用过 finalize() 方法。但是由于任何一个对象的 finalize() 方法只会被系统自动调用一次，所以当进行第二次回收的时候该对象将会被垃圾回收器进行收集。 四、再谈引用无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象的存活都与“引用有关”。 强引用Object obj = new Object() 这一类的引用称之为强引用，强引用在程序代码之中是普遍存在的。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用软引用是用来描述一些还有用但并非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。JDK 提供了 SoftReference 类来实现软引用。 弱引用强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器发生工作时，无论内存是否足够，都会回收掉弱引用关联的对象。 JDK 提供了 WeakReference 来实现弱引用。 虚引用最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 JDK 提供了 PhantomReference 类来实现虚引用","categories":[],"tags":[{"name":"JVM学习笔记","slug":"JVM学习笔记","permalink":"http://wildergao.github.io/tags/JVM学习笔记/"}]},{"title":"JVM学习笔记: GC（1）","slug":"JVM学习笔记-GC（1）","date":"2018-05-28T06:57:22.000Z","updated":"2018-05-28T16:16:08.000Z","comments":true,"path":"2018/05/28/JVM学习笔记-GC（1）/","link":"","permalink":"http://wildergao.github.io/2018/05/28/JVM学习笔记-GC（1）/","excerpt":"","text":"JVM GC (1)最近我想慢慢把我学到的JVM知识整理到笔记中，不然看书看了之后就忘记真的是凉凉。 在接触GC之前，我们先来看一下 Java 内存区域 运行时数据区域JVM运行数据分为几部分： 程序计数器 Java 虚拟机栈 本地方法栈 Java 堆 方法区（永久代） 运行时常量 直接内存 程序计数器​ 在代码执行的过程中，当执行完某一行代码之后我们需要执行下一个指令，这个指令有可能是循环、跳转、异常处理等，而程序计数器的功能就是选取下一条需要执行的字节码指令。 ​ 程序计数器是线程特有的，各条线程之间计数器互不影响，独立存储，这称为“线程私有”。 ​ 程序计数器通过改变计数器的值来选取下一条需要执行的字节码指令。 Java 虚拟机栈​ 和程序计数器一样，虚拟机栈也是线程私有的，线程之间互不影响。 ​ 虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到岀栈的过程。 ​ 局部变量表存放了编译期可知的各种基本数据类型、对象引用（reference 类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。 本地方法栈​ 本地方法栈（Native Method Stack） 于虚拟机所返回的作用时非常相似的，他们之间的区别是不过虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。而虚拟机规范中对本地方法栈中方法使用的语言，使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（HotSpot）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflow 异常和 OOM 异常。 Java 堆（GC堆）​ Java Heap 是 Java 虚拟机所管理的内存中最大的一块。Java 堆并不是线程私有的，所有的线程都共享一个 Java 堆。几乎所有的对象实例都在 Java 堆中进行分配，与此同时 Java 堆也是垃圾收集管理的主要区域。 ​ 从内存回收角度来看的话，Java 堆可以细分为 新生代和老年代 ，更细的话新生代还可以划分为 Eden 区、From Survivor区、To Survivor区。 ​ 从内存分配角度来看的话，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区。 ​ Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果Java 堆中新生代或者老年代的内存没有被 GC 掉导致内存溢出的话会产生OOM异常（我就遇到了这样的情况）。 方法区​ 方法区也是线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区也有人称为 “永久代” 。 ​ Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾回收。相对而言，垃圾收集行为在这个区域是比较少见的，但并非数据进入了方法区就如同永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分的区域的回收确实是由必要的。 （1）运行时常量池​ 运行时常量池是方法区的一部分。常量池用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 ​ 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OOM 异常。 ​ 运行时常量池相对于 Class 文件常量池的另外一个重要特种是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预制入 Class 文件中常量池的内容才能既然怒方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的便是 String 类的 intern 方法。 （2）String.intern() 方法​ String.intern() 这是一个 native 方法，它的作用是：如果字符串常量池中已经包含了一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象，否则将此 String 对象包含的字符串添加到常量池中，并返回此字符串的引用。在 JDK1.6 和 JDK1.7中常量池在内存中的位置不一样，我们来看一段代码： 1234567891011public static void main(String[] args) &#123; String s = new String(\"1\"); s.intern(); String s2 = \"1\"; System.out.println(s == s2); String s3 = new String(\"1\")+new String(\"1\"); s3.intern(); String s4 = \"11\"; System.out.println(s3 == s4);&#125; ​ 这段代码在 JDK1.6 的运行结果是都为false，在 JDK1.7 以上结果是 false 和 true JDK1.6解释 ​ JDK 1.6 的常量池是放在Perm区，Perm区和 Java Heap 区是完全分开的。引号声明的字符串是在常量池中生成的，而new出来的字符串是存放在 Java Heap 中的。因此两种不同声明方式的字符串存放的位置完全不相同，所以结果都为 false 。 JDK 1.7解释​ JDK 1.7 的常量池放在了 Java Heap 的一个区域中，并不放在 Perm 区中 我们来分析一下上面那段代码： String s = new String(“1”) 之后在 Java Heap 区存放了这个对象，在常量池中存放了“1”，调用了intern()方法之后发现“1” 已经在常量池中，s 便不会指向常量池中的常量。当声明String s2 = “1” ，s2 会指向常量池中的字符串“1”，而s并没有指向常量池中的字符串，所以返回false。 String s3 = new String(“1”)+new String(“1”) ，常量池中会存放“1”，Java Heap区存放了“11”，调用intern() 方法之后发现常量池并没有“11”，所以将“11”保存到常量池中并指向该常量，最后在声明 s4 的时候会指向常量池的“11”，因此比较后的结果是 true 直接内存​ 直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存被频繁使用，也可能出现OOM异常。 ​ 本机直接内存的分配不会收到 Java 堆大小的限制，但是会收到本机总内存大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机总参数时，会根据实际内存设置 -Xmx 等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级别的限制），从而导致动态扩展时出现 OOM 异常","categories":[],"tags":[{"name":"JVM学习笔记","slug":"JVM学习笔记","permalink":"http://wildergao.github.io/tags/JVM学习笔记/"}]},{"title":"关于线程的一些总结","slug":"关于线程的一些总结","date":"2018-04-24T06:41:13.000Z","updated":"2018-04-24T07:00:32.000Z","comments":true,"path":"2018/04/24/关于线程的一些总结/","link":"","permalink":"http://wildergao.github.io/2018/04/24/关于线程的一些总结/","excerpt":"","text":"什么是 linux 进程进程：进程是指正在执行的程序，是程序正在执行的一个实例。当用户下达运行程序的命令后，就会产生一个进程。进程是系统进行资源分配和调度的一个独立单位，也就是说进程具有独立的地址空间，一个进程的崩溃不会影响到其它进程的进行。进程由程序指令、和从文件、其它程序中读取的数据或者用户的输入组成。 ​ 可以举一个例子，把程序比作菜单上面的菜，那么制作出这一盘菜需要的料理采购、厨师、调料以及通知服务员上菜这一整个过程就是一个进程。其中采购和调料可以看成数据的读取，厨师炒菜过程看成逻辑处理，通知服务员则看成是通信。 ​ linux中的进程有三个信息，分别是 PID、COMMAND、CMD PID：pid是一个整数，每一个进程都有一个唯一的PID来代表自己的身份 COMMAND：进程的简称 CMD：进程所对应的程序以及运行时所带的参数 创建一个进程 ​ 除了init进程是计算机开机时候系统建立的，其它进程都是通过老的进程复制自身得到，复制之后内存中就会开辟出一片新的内存空间给新的进程。 程序和进程区别 ​ 进程是程序的具体实现，同一个程序可以被执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个线程。 参考博客： http://www.jb51.net/article/111091.htm https://www.kancloud.cn/kancloud/understanding-linux-processes/52208 http://www.techweb.com.cn/network/system/2017-06-24/2545223.shtml https://blog.csdn.net/laviolette/article/details/51507642 什么是linux线程​ 我翻查了一些博客，博客上说 linux 对线程的概念并没有 windows 那么清晰 ​ 线程概念：线程是进程的实体对象，我将它理解为进程的基本单位，一个进程内会有多条线程并行或者伪并行执行，但是线程本身不拥有系统资源，只拥有一点在运行中不可缺少的资源（程序计数器，一组寄存器和栈），同一个进程内的线程共享进程内的所有资源。 线程与线程之间的通信方式线程间的通信方式按照我的理解分为两种： 通过共享变量方式进行通信 方法名称 描述 notify() 通知一个在对象上等待的线程，使其从wait()方法中返回，而返回的前提是该线程获取到了对象的锁 notifyAll() 通知所有等待在该对象的线程 wait() 调用该方法会使线程进入waiting 状态，只有等其它线程唤醒或者该线程被中断的时候才会返回，调用wait()方法之后会释放锁 wait(long time) 等待一定的时间自动返回 通过队列来实现线程的通信​ 一个线程和另一个线程之间通信时，只需要向（处于另一个线程中的）消息队列中发送（或接收）消息，而不必一直等待对方是否响应。 进程间的通信方式管道什么是管道？ ​ 在 linux 中，管道本质上来说也是一种文件，管道的结构如下（借助了文件系统的file结构和 VFS（不懂这个是什么概念）的索引结点inode，通过将两个file 结构指向同一个临时的VFS索引结点，而这个VFS索引结点又指向一个物理页面实现的） ​ 管道创建之后的通信： ​ 1、父进程调用 pipe 开辟管道，得到指向两个文件描述符指向管道的两端，一端是读端，一端是写端 ​ 2、父进程调用 fork 创建子进程，子进程同样有两个文件描述符指向同一管道 ​ 3、父进程关闭管道读端，子进程关闭管道写端。这样父进程可以往管道里写，子进程可以往管道里读，管道是用唤醒队列实现的，数据从写端流入从读端流出，这样就实现了进程之间的通信。 管道的特点： ​ 1、管道只允许具有血缘关系的进程之间进行通信（但是有名管道允许无亲缘关系进程间的通信） ​ 2、管道只允许单向通信 ​ 3、依赖文件系统 ​ 4、面向字节流 ​ 5、管道随进程，进程在管道在，进程消失管道对应的端口也关闭，两个进程消失管道也对应消失 消息队列什么是消息队列？ ​ 消息队列提供了一种从一个进程想另一个进程发送一个数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。消息队列是链表队列，它通过内核提供一个struct msqid_ds *msgque[MSGMNI]向量维护内核的一个消息队列列表，因此linux系统支持的最大消息队列数由msgque数组大小来决定，每一个msqid_ds表示一个消息队列，并通过msqid_ds.msg_first、msg_last维护一个先进先出的msg链表队列。 ​ 当发送一个消息到消息队列的时候，把发送的消息构造成一个msg结构对象，并添加到链表队列，同样接收消息是从msg链表队列尾部查找到匹配的msg节点，从队列中删除该msg节点。 消息队列和管道的比较： 1、消息队列进行通信的进程可以是不相关的进程（进程之间没有进程关系，当然命名管道也可以） 2、两者都是通过发送和接收的方式来传递数据 3、消息队列发送数据用msgsnd，接收数据用 msgrcv，管道使用的是read 和 write 4、消息队列可以独立于发送和接收进程而存在，从而消除了管道打开关闭而可能产生的困难 5、同时通过发送消息还可以避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法 参考：https://blog.csdn.net/ljp1919/article/details/52556555 信号量什么是信号量？ ​ 信号量的本质是一种数据操作锁,它本身不具有数据交换的功能,而是通过控制其他的通信资源(文件,外部设备)来实现进程间通信,它本身只是一种外部资源的标识。在任一时刻只有一个执行线程能够访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。（我把它理解为类似于 锁 的东西）。 ​ 由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的： ​ P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行 ​ V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1. 如何进行通信？ ​ 当两个进程之间要进行通信的时候，两个进程之间将共享信号量sv，当一个进程执行了P(sv) 操作，它将得到信号量。第二个进程将被阻止进入到临界区而会被挂起等待第一个进程离开临界区域之后释放信号量之后，这时第二个进程才可以恢复执行。 共享内存区什么是共享内存？ ​ 顾名思义，当一个程序想和另一个程序通信的时候，内存会将这两个程序生成一个公共的内存区域。这块被两个进程分享的内存区域叫做共享内存。但是，我们的程序中仅仅有一个进程訪问了共享内存。因此在集中展示了共享内存机制的同一时候。我们避免了让代码被同步逻辑搞得混乱不堪。 为了简化共享数据的完整性和避免同一时候存取数据，内核提供了一种专门存取共享内存资源的机制。这称为相互排斥体或者mutex对象 通过共享区域通信的步骤？ ​ 1、获取 mutex 对象，锁定共享区域 ​ 2、将要通信的数据写入共享区域 ​ 3、释放 mutex 对象 linux 共享内存之间的通信？ ​ （linux 共享内存模型说道 内存地址与内存页面之间的映射，不太明白这个是如何进行映射的） 参考博客：https://www.cnblogs.com/blfbuaa/p/7145946.html https://blog.csdn.net/lfw19891101/article/details/5994927 线程如何切换线程切换过程： 1.虚拟机启动之后，就进入了解释器的死循环，一直解释执行pc指针对应的java字节码。 每个现在对应着一个stack，方面调用的时候，会在其上分配栈帧，由sp，fp等指针指向。 线程调度，其实就是记录下当前线程的pc，sp，fp等指针，并将这几个指针（pc，sp，fp等，都是全局的）指向下一个将要执行的线程的相应位置。 当恢复上述的几个指针之后，就切换回之前的线程了 java 线程状态的切换？ ​ 线程所拥有的资源线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.。 一个进程中的所有线程共享该进程的地址空间，但是他们有各自独立的栈 线程共享资源 线程独享资源 地址空间 程序计数器 全局变量 寄存器 打开的文件 栈 子进程 状态字 闹铃 信号及信号服务程序 记账信息 参考博客：https://blog.csdn.net/liukaiyu_ak/article/details/52368303","categories":[],"tags":[]},{"title":"JVM学习笔记（一）：字节码的编译原理","slug":"JVM学习笔记（一）","date":"2018-03-20T08:41:13.000Z","updated":"2018-03-23T08:19:16.000Z","comments":true,"path":"2018/03/20/JVM学习笔记（一）/","link":"","permalink":"http://wildergao.github.io/2018/03/20/JVM学习笔记（一）/","excerpt":"","text":"JVM：字节码的编译原理​ JVM 并不会与 Java 语言 “ 终生绑定 ” ，任何语言编写的程序都可以运行在 JVM 中，前提是源码的编译结果满足并包含 Java 虚拟机的内部指令集、符号表以及其它的辅助信息，它就是一个有效的字节码文件，就能被虚拟机所识别并装载运行。 ​ Java 源码编译为字节码时所要经历的步骤为：词法解析 –&gt; 语法解析 –&gt; 语义解析 –&gt; 生成字节码 词法解析 ：词法解析就是将 Java 源码中的关键字和标示符等内容转换为符合 Java 语法规范的 Token 序列，然后按照指定的顺序规则进行匹配校验（所谓的关键字指的是 public ， private等关键字）； 语法解析：语法解析就是将词法解析后的 Token序列整合为一棵结构化的抽象语法树； 语义解析：语义解析的目的就是为了将之前语法解析步骤所产生的语法树扩充得更加完善，后续编译器将会使用语义解析后的语法树来生成字节码 词法解析步骤​ 词法解析器的主要任务就是将 Java 源码中的关键字和标识符等内容转换为符合 Java 语法规范的 Token 序列，为之后的语法解析步骤做准备 ​ 如图所示的词法解析过程，我们要知道 Scanner 是主要任务是按照单个字符的方式 读取源文件中的标示符等内容。 但是 Scanner 的任务只是读取源码的字符集合，但是解析的主要步骤交给 JavacParser 来解决，主要调用了 parseCompilationUnit ( ) 方法 ；nextToken ( ) 方法则读取一个个字符交给 JavaParser 转换为 Token 序列。 Token 序列​ Token 究竟是什么呢？其实 Token 无非就是一组对应源码字符集合的单词序列。 123456789EOF, ERROR, IDENTIFIER. ABSTRACT(\"abstract\"), ASSERT(\"assert\"), BOOLEAN(\"boolean\"), ...... PACKAGE(\"package\"), ...... 源码字符集合与 Token 之间的对一个关系​ 看了《 Java 虚拟机精讲 》之后，我自己对这两者的关系的理解大概如下： 源码字符集合在转换为 Token序列之前会先将被一个字符转换为对应的 Name 对象，也就是说每一个字符会对应一个 Name 对象。 负责实际 Token 转换的 Keywords 会将 Token 常量转换为 Name 对象，并将 Token 的信息储存在 Name 对象内部的 Table 类中 这样的话源码字符和 Token 通过了 Name 对象就有了一定的关系 用 Keywords 类中的数组 key 用于保存源码字符集合与 Token 之间的对应关系 调用 key( ) 方法获取指定 Token​ 每一个源码字符集合其实就是一个 Name 对象，一旦源码字符集合与 Token 之间成功构建起对应关系之后，当词法解析期调用 Keywords 类的 key( ) 方法时，传入与 Token 对应的 Name 对象就可以成功获取指定的 Token： 123public Token key (Name name) &#123; return (name.getIndex() &gt; maxKey) ? IDENTIFIER : key[name.getIndex()];&#125; ​ 源码字符集合与 Token 之间的对应关系就保存在数组 key 中，其中 Name 类的 getIndex( ) 方法用于返回 Name 对象当前索引，通过这个索引就可以从数组 key 中获取他们的 Token。 调用 nextToken( )计算 Token 的获取规则​ 当成功获取到指定的 Token 后，JavacParser 类就会匹配当前的第一个 Token 是否匹配 Token.PACKAGE ，如果匹配成功的话，再由词法解析期获取下一个 Token ，继续匹配是否是 Token.IDENTIFIER（标识符） ，接下来再匹配 Token.DOT（点） 、 Token.IDENTIFIER 和 Token.SEMI（分号）。这样的话，一个完整的 package 关键字声明就解析完成。 最后，调用 parseCompilationUnit( ) 方法进行匹配，当然 Token 的匹配顺序和 Token 的读取顺序要保持一致，parseCompilationUnit ( ) 方法会将 Token 序列整合为一棵结构化的抽象语法树。 语法解析步骤​ 根据我的理解，语法解析的步骤起始也是在 parseCompilationUnit ( )方法中实现的，其实 parseCompilationUnit ( ) 里面调用了词法解析，语法解析，语义解析和生成字节码四个步骤的方法。怎么说呢，在词法解析之后，源码字符集变成了一个个 Token 序列，但是这些序列都是单一的没有任何的关联，通过语法解析，将匹配后的 Token 序列整合为一棵结构化的抽象语法树。比如说 try … catch 需要联系起来等情况。我们一起来看一下 ​ 语法解析中一个重要的类就是 JCTree 类，它实际上与语法树中的每一个语法结点保持着密不可分的关系，因为语法树中的每一个语法结点实际上都直接或者间接地继承了 JCTree 类，并且这些语法结点对象都以静态内部类的形式定义在类中。根据理解我画出了关系图： 12345678st=&gt;operation: Tokenop=&gt;operation: 语法结点cond=&gt;operation: JCTree 类achieve=&gt;condition:实现对应 Tree 接口e=&gt;endst-&gt;op-&gt;cond-&gt;eachieve(yes)cond(no)-&gt;op 调用 qualident ( ) 方法解析 package 语法结点​ 当词法解析器成功地将 package 关键字声明转换为 Token 并完成词法解析后，就会调用 qualident ( ) 方法根据 Token.PACKAGE 解析为 package 语法结点 1234567891011public JCExpression qualident() &#123; /* 解析为 JCIdent 语法结点*/ JCExpression t = toP (F.at(S.pos()).Ident(ident())) ; while (S.token() == DOT)&#123; int pos = S.pos(); S.nextToken(); /* 解析为 JCFieldAccess 语法节点*/ t = toP(F.at(pos).Select(t,ident())); &#125; return t;&#125; ​ 上述代码中，假如 package 声明的关键字只有一级目录的时候就会调用 Ident( ) 方法将它解析成为一个 JCIdent 语法结点；反之当 package 关键字声明中有多级目录时，qualident( ) 方法就会通过循环迭代的方式调用语法解析器将 package 关键字声明解析为嵌套的 JCFieldAccess 语法结点，接下来我们来看看这两个方法的源代码： 12345public JCIdent Ident (Name name)&#123; JCIdent tree = new JCIdent(name , null); tree.pos = pos; return tree;&#125; 123456public JCFieldAccess Select(JCExpression selected, Name selector)&#123; // 根据Name 对象解析出嵌套 JCFieldAccess 语法结点 JCFieldAccess tree = new JCFieldAccess(selected, selector, null); tree.pos = pos; return tree;&#125; ​ 我们可以看到，JCIdent 和 JCFieldAccess 的方法参数需要的是 Name 对象，也就是说在解析语法树或者语法节点时，首先需要将 Token 转换为对应的 Name 对象。也就是说，调用 ident( ) 方法会返回一个与 Token 对应的 Name 对象。 调用 importDeclaration( ) 方法解析 import 语法树​ 调用 importDeclaration ( ) 方法的步骤和解析package 语法结点是一样的，当 import 关键字声明中只有一层目录时就调用 Ident( ) 解析出一个 JCIdent 语法结点，如果是多级目录的话就调用 Select( ) 方法解析成为嵌套的 JCFieldAccess 语法节点。有一个需要注意的是 import 解析时会先判断是否有 Token.STATIC 匹配，检测 import 关键字声明中是否包含 static 静态导入。 ​ import 解析完成之后，将会调用 Import ( ) 方法，将之前解析过的语法节点整合成一棵 JCImport 语法树。 ​ 调用 classDeclaration ( ) 方法解析 class 语法树​ 当词法解析器成功将 import 关键字解析并整合成 JCImport 语法树后，在 parseCompilationUnit ( ) 方法内部就会通过 typeDeclaration( ) 方法调用 classOrInterfaceOrEnumDeclaration( ) 方法将 class 主体信息解析为一棵 JCClassDecl 语法树。从这个方法名可以看出，方法中在检验的时候会考虑到 class 、interface 、 enum 三种情况的校验，并且还要注意的就是不管是class、interface 还是 enum 最后都是解析成一棵 JCClassDecl 语法树。大致的理解就是这样子… ​ ​ 当将 class 部分整合成一棵 JCClassDecl 语法树之后，parseCompilationUnit( ) 方法就会调用语法解析器的 TopLevel ( ) 将之前解析过的 package、import 和 class 语法树等内容信息全部整合成一棵 JCCompilationUnit 语法树。 语义解析步骤​ 经过语法解析后的语法树还不够完善，主要会经历的操作如下： 为没有构造方法的类型添加缺省的无参构造方法 检查任何类型的变量在使用前是否都已经经历过初始化 检查变量类型是否与值匹配 将 String 类型的常量进行合并处理 检查代码中的所有操作语句是否可达 异常检查 解除 Java 语法糖 经历过一系列的语义解析步骤之后，就构成了一个完善的编译前提 生成字节码​ javac编译器最后的任务就是调用 Gen 类将这棵语法树编译为 Java 字节码文件。所谓的编译字节码，就是将符合 Java 语法规范的 Java 代码转换为符合 JVM 规范的字节码文件。在此需要注意的是：JVM 的架构模型是基于栈的，在 JVM 中所有的操作都需要经过入栈和岀栈来完成。 好啦~大概的内容就到这里了，至于后面 JVM 的架构模型这一部分将在后面的章节进行整理","categories":[],"tags":[{"name":"JVM学习笔记","slug":"JVM学习笔记","permalink":"http://wildergao.github.io/tags/JVM学习笔记/"}]},{"title":"netty总结三","slug":"netty总结三","date":"2018-03-10T10:39:51.000Z","updated":"2018-03-11T11:37:24.000Z","comments":true,"path":"2018/03/10/netty总结三/","link":"","permalink":"http://wildergao.github.io/2018/03/10/netty总结三/","excerpt":"","text":"Netty 总结三我们来看一下客户端代码，虽然和服务器端有点相似，但是原理还是有区别的 1234567891011121314151617181920212223242526272829303132333435public class HelloClient &#123; Logger logger = LoggerFactory.getLogger(HelloClient.class); /** * 连接服务器端 * @param ip * @param port */ public void connect(String ip , int port)&#123; EventLoopGroup clientGroup = new NioEventLoopGroup(); //客户端使用BootStrap try &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(clientGroup) .channel(NioSocketChannel.class) .option(ChannelOption.SO_KEEPALIVE , true) .option(ChannelOption.CONNECT_TIMEOUT_MILLIS , 3000) //handler 方法在初始化时就会执行 .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new LineBasedFrameDecoder(1024)) .addLast(new StringDecoder()) .addLast(new ClientHandler()); &#125; &#125;); ChannelFuture future = bootstrap.connect(ip, port).sync(); future.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; clientGroup.shutdownGracefully(); &#125; &#125; Netty 客户端创建时序图 步骤1：用户线程创建 BootStrap 实例，设置创建客户端相关参数，异步发起客户端连接 步骤2：创建处理客户端连接、I/O 读写的 Reactor 线程组 NioEventLoopGroup 步骤3：通过 BootStrap 的 ChannelFactory 和用户指定的 Channel 类型创建用于客户端连接的 NioSocketChannel 步骤4：创建默认的 ChannelHandlerPipeline ，用于调度和执行网络事件 步骤5：异步发起 TCP 连接，判断连接是否成功。如果成功则直接将 NioSocketChannel 注册到多路复用器上，监听读操作位，用于数据报读取和消息发送；如果没有立即连接成功则注册连接监听到多路复用器，等待连接结果 步骤6：注册对应的网络监听状态到多路复用器 步骤7：由多路复用器在I/O现场中轮询各 Channel ，处理连接结果 步骤8：如果连接成功，设置 Future 结果，发送连接成功事件，触发 ChannelPipeline 执行 步骤9：由 ChannelPipeline 调度执行系统和用户的 ChannelHandler ，执行业务逻辑 源码分析客户端连接辅助类 BootStrap​ 在NIO模式中一个线程可以处理多个 TCP 连接。客户端相对于服务器来说，只需要创建一个处理 I/O 读写的线程组即可： 12345678910public B group(EventLoopGroup group) &#123; if (group == null) &#123; throw new NullPointerException(\"group\"); &#125; else if (this.group != null) &#123; throw new IllegalStateException(\"group set already\"); &#125; else &#123; this.group = group; return this; &#125;&#125; ​ TCP 参数设置接口：创建客户端套接字的时候通常都会设置连接参数。BootStrap 也提供了 TCP 参数设置接口，通过 option 方法进行连接 ​ 各种 TCP 参数极其含义 12345678910111213141516171819public &lt;T&gt; B option (ChannelOption&lt;T&gt; option , T value)&#123; if(option == null)&#123; throw new NullPointerException(\"option\"); &#125;else &#123; Map var3; if (value == null)&#123; var3 = this.options; //options是一个LinkedMap synchronized(this.options)&#123; this.option.remove(option); &#125; &#125; else &#123; var3 = this.options; synchronized(this.options)&#123; this.options.put(option , value); &#125; &#125; return this; &#125;&#125; ​ 我们可以看到，在设置参数的时候采用了Map，将各个参数一一对应 ​ channel 接口：用于指定客户端使用的 Channel 接口，对于 TCP 客户端，默认使用 NioSocketChannel 。和服务端一样，使用ChannelFactory通过反射来创建 channel 对象： 1234567public BootStrap channel(Class&lt;? extends Channel&gt; channelClass) &#123; if (channelClass == null)&#123; throw new NullPointerException(\"channelClass\"); &#125; else &#123; return this.channelFactory(new BootstrapChannelFactory&lt;Channel&gt;(channelClass)); &#125;&#125; ​ 设置 Handler 接口：BootStrap 提供了 ChannelInitializer ， 先调用 channelRegister 接口注册链路，当 TCP 链路注册成功之后，调用 initChannel 接口，用于设置用户 ChannelHandler： 123456789101112131415161718192021public final void channelRegistered (ChannelHandlerContext ctx) throws Exception &#123; ChannelPipeline pipeline = ctx.pipeline(); boolean success = false; try&#123; initChannel ((C) ctx.channel()); pipeline.remove(this); ctx.fireChannelRegistered(); success = true ; //...... &#125;&#125;.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new LineBasedFrameDecoder(1024)) .addLast(new StringDecoder()) .addLast(new ClientHandler()); &#125; &#125;); 客户端连接操作 创建和初始化 NioSocketChannel 12345678private ChannelFuture doConnect (final SocketAddress remoteAddress , final SocketAddress localAddress)&#123; final ChannelFuture regFuture = initAndRegister(); final Channel channel = regFuture.channel(); if (regFuture.cause() != null)&#123; return regFuture; &#125; //...........&#125; 从 NioEventLoopGroup 中获取 NioEventLoop ， 然后使用其作为参数创建 NioSocketChannel 1234Channel createChannel() &#123; EventLoop eventLoop = group().next(); return channelFactory().newChannel(eventLoop);&#125; 初始化 Channel 之后，将其注册到 Selector 上（也就是注册到 EventLoop 上，之前说过一个 EventLooo 对应多个Channel ， 而一个 Channel 对应一个EventLoop ） 12ChannelPromise regFuture = channel.newPromise();channel.unsafe().register(regFuture); 链路创建成功之后，发起异步的 TCP 连接，从连接开始，操作就切换到了channel 对应的EventLoop 线程进行了，也就是异步操作： 12345678910111213141516private static void doConnect0 (final ChannelFuture regFuture , final Channel channel , final SocketAddress remoteAddress , final SocketAddress localAddress , final ChannelPromise promise)&#123; channel.eventLoop().execute(new Runnable()&#123; @Override public void run()&#123; if (regFuture.isSuccess()) &#123; if (localAddress == null)&#123; channel.connect(remoteAddress , promise); &#125; else &#123; channel.connect(remoteAddress , localAddress , promise); &#125; //...... &#125; &#125; &#125;)&#125; ​ doConnect0 最终调用 HeadHandler 的connect 方法： 1234public void connect (ChannelHandlerContext ctx , SocketAddress remoteAddress , SocketAddress localAddress , ChannelPromise promise) throws Exception &#123; unsafe.connect(remoteAddress , localAddress , promise); &#125; ​ AbstractNioUnsafe 的 connect 操作如下： 12345if (doConnect(remoteAddress , localAddress))&#123; fulfillConnectPromise (promise , wasActive);&#125;else&#123; //......&#125; ​ 执行 connect() 操作后有三种结果： （1）连接成功，返回 true （2）暂时没有连接上，服务端没有返回 ACK 应答，连接结果不确定，返回 False （3）连接失败，直接抛出 I/O 异常 ​ 注意：如果是第二种结果，需要将 NioSocketChannel 中的 selectionKey 设置为 OP_CONNECT ，监听连接结果 异步连接返回之后，需要判断连接结果： 连接成功，出发 ChannelActive 事件 123if(!wasActive &amp;&amp; isActice())&#123; pipeline().fireChannelActive(); //最终将 NioSocketChannel 中的selectionKey 设置为 SelectionKey.OP_READ，用于监听网络读操作&#125; 没有立即连接上，则注册 SelectionKey.OP_CONNECT 到多路复用器 123456789boolean success = false ; try &#123; boolean connected = javaChannel().connect(remoteAddress); if (!connected)&#123; selectionKey().interestOps(SelectionKey.OP_CONNECT)l &#125; success = true ; return connected ; &#125; ​ 连接发生异常，则关闭链路，进入连接失败处理流程 12345finally&#123; if (!success)&#123; doClose(); &#125;&#125; 异步连接结果通知​ NioEventLoop 的 Selector 轮询客户端连接 Channel ， 当服务端返回握手应答之后，对连接结果进行判断 12345678910111213if ((readOps &amp; SelectionKey.OP_CONNECT) != 0) &#123; int ops = k.interestOps(); ops &amp;= ~SelectionKey.OP_CONNECT; k.interestOps(ops); unsafe.finishConnect();&#125;//以下是finishConnect 的代码try&#123; boolean wasActive = isActive(); doFinishConnect(); fulfillConnectPromise(connectPromise , wasActive);&#125; ​ doFinishConnect 用于判断 JDK 的 SocketChannel 的连接结果，如果返回 true 表示连接成功，其他值或者发生异常表示连接失败 12345protected void doFinishConnect() throws Exception &#123; if (!javaChannel().finishConnect())&#123; throw new Error(); &#125;&#125; ​ 连接成功之后，调用 fulfillConnectPromise 方法，触发链路激活事件，该事件由 ChannelPipeline 进行传播： 123456789private void fulfillConnectPromise (ChannelPromise promise , boolean wasActive)&#123; boolean promiseSet = promise.trySuccess(); if (!wasActive &amp;&amp; isActive())&#123; pipeline().fireChannelActive(); &#125; if(!promiseSet)&#123; close(voidPromise()); &#125;&#125; 客户端连接超时机制 用户在创建 Netty 客户端的时候，可以通过 ChannelOption.CONNECT_TIMEOUT_MILLIS 配置项设置连接超时时间 1234bootstrap.group(clientGroup) .channel(NioSocketChannel.class) .option(ChannelOption.SO_KEEPALIVE , true) .option(ChannelOption.CONNECT_TIMEOUT_MILLIS , 3000) 发起连接的同时，启动连接超时检测定时器 如果在连接超时之前获取到结果，则删除连接超时定时器，防止其被触发 123456789public void finishConnect()&#123;&#125;finally&#123; if (connectTimeoutFuture != null) &#123; connectTimeoutFuture.cancel(false); &#125; connectPromise = null; &#125;//......&#125; 大致的连接流程就是这样子了~参考了《Netty 权威指南第二版》","categories":[],"tags":[{"name":"Netty 我有话说","slug":"Netty-我有话说","permalink":"http://wildergao.github.io/tags/Netty-我有话说/"}]},{"title":"netty总结二","slug":"netty总结二","date":"2018-03-05T07:02:53.000Z","updated":"2018-03-10T10:41:26.000Z","comments":true,"path":"2018/03/05/netty总结二/","link":"","permalink":"http://wildergao.github.io/2018/03/05/netty总结二/","excerpt":"","text":"Netty 总结二我们来看一下之前的Hello World 服务端代码： 123456789101112131415161718192021222324252627282930313233343536public class HelloServer &#123; Logger logger = LoggerFactory.getLogger(HelloServer.class); private int port; public HelloServer(int port)&#123; this.port = port; &#125; public void bind()&#123; //处理NIO事件的多线程循环器，一个用来接收新来的连接，一个用来处理已经被接收的连接 EventLoopGroup eventLoopGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); //启动NIO配置的服务类 try &#123; //启动NIO服务的配置类 ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(eventLoopGroup, workerGroup) //服务器端选择的Channel是ServerSocketChannel .channel(NioServerSocketChannel.class) //childHandler 在客户端执行的时候才会触发 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new HelloServerHandler()); &#125; &#125;) .option(ChannelOption.SO_BACKLOG, 1024); ChannelFuture future = bootstrap.bind(port).sync(); //服务器监听端口，阻塞模式，直到服务器链路关闭之后main才关闭 future.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; workerGroup.shutdownGracefully(); eventLoopGroup.shutdownGracefully(); &#125; &#125; 服务端创建的时序图 步骤一：创建 ServerBootstrap 实例 ​ ServerBootstrap 是 Netty 服务端的启动辅助类，提供了一些列方法用于设置服务器启动相关的参数。在创建 ServerBootstrap 时不需要任何的构造参数，那是因为构造参数太多了，如果使用传统的方法来将所有的参数填入，会不知道填进去的每一个代表什么意义。因此采用的时Builder 模式来进行构造，简单来说就是将构造参数变为相应的构造方法，一个一个参数来构造。 Builder模式 步骤二：设置并绑定 Reactor 线程池 ​ Netty 的 Reactor 线程池是EventLoopGroup ，它实际上是 EventLoop 的数组。EventLoop 的职责是处理所有注册到本线程多路复用器 Selector 上的 Channel ， Selector 的轮询操作由绑定的 EventLoop 线程 run 方法驱动，在一个循环体内执行。EventLoop 的职责不仅仅是处理网络 IO 事件，用户自定义的 Task 和定时任务 Task 也统一由 EventLoop 负责处理。从调度层看，也不存在从EventLoop线程中再启动其它类型的线程用于异步执行另外的任务，这样避免了多线程并发操作和锁竞争。 ​ 简单的就是说，一个Channel 对应一个EventLoop，而一个EventLoop 对应着多个Channel ，当一个Channel 绑定到这个EventLoop 上之后，这个Channel 之后的所有操作都将由这个EventLoop 对应的线程处理，不会有并发的问题产生。 步骤三：设置并绑定服务端 Channel ​ 作为服务端需要创建的是 ServerSocketChannel ，Netty 对原生的NIO类库进行了封装实现了NioServerSocketChannel 。Netty 通过工厂类，利用反射创建NioServerSocketChannel 对象。 1234567public ServerBootstrap channel(Class&lt;? extends ServerChannel&gt; channelClass)&#123; if(channelClass == null)&#123; throw new NullPointerException(\"channelClass\"); &#125; //通过反射创建 NioServerSocketChannel 对象 return channelFactory(new ServerBootstrapChannelFactory&lt;ServerChannel&gt;(channelClass));&#125; 步骤四：链路建立的时候创建并初始化 ChannelPipeline 。 ​ ChannelPipeline 的本质就是负责处理网络事件的责任链，负责管理和执行 ChannelHandler 。 步骤五：添加并设置ChannelHandler ​ ChannelHandler 是 Netty 提供给用户定制和扩展的关键接口，比较实用的系统ChannelHandler如下： （1）系统编解码框架 —— ByteToMessageCodec； （2）用于基于长度的半包解码器 —— LengthFieldBasedFrameDecoder； （3）码流日志打印 —— LoggingHandler （4）SSL安全认证Handler —— SslHandler （5）链路空间检测Handler —— IdleStateHandler （6）流量整型Handler —— ChannelTrafficShapingHandler （7）Base64编解码 —— Base64Decoder 和 Base64Encoder 步骤六：绑定并启动监听端口 ​ 在绑定监听端口之前系统会做一系列的初始化和检测工作，完成之后，会启动监听端口，并将ServerSocketChannel 注册到Selector 上监听客户端连接 123protected void doBind(SocketAddress localAddress)&#123; javaChannel().socket().bind(localAddress , config.getBacklog());&#125; 步骤七：Selector 轮询。 ​ 由Reactor线程NioEventLoop 负责调度和执行 Selector 轮询操作，选择准备就绪的Channel 集合，当轮询到准备就绪的Channel 之后，就由Reactor 线程NioEventLoop执行ChannelPipeline 的相应方法，最终调度并执行ChannelHandler。 源码分析首先通过构造函数创建 ServerBootstrap ，随后创建两个 EventLoopGroup 实例，通过ServerBootstrap 的 group 方法将两个EventLoopGroup 实例传入 1234567891011public ServerBootstrap group(EventLoopGroup parentGroup , EventLoopGroup childGroup)&#123; super.group(parentGroup); if(childGroup == null)&#123; throw new NullPointerException(\"childGroup\"); &#125;else if (this.childGroup != null) &#123; throw new IllegalStateException(\"childGroup set already\"); &#125; else &#123; this.childGroup = childGroup; return this; &#125;&#125; parentGroup 被传入了父类构造器中，也就是AbstractBootstrap的构造器 12345678910public B group(EventLoopGroup group) &#123; if (group == null) &#123; throw new NullPointerException(\"group\"); &#125; else if (this.group != null) &#123; throw new IllegalStateException(\"group set already\"); &#125; else &#123; this.group = group; return this; &#125;&#125; 线程组和线程类型设置完成后，需要设置服务端 Channel 用于端口监听和服务端链路接入。Netty 通过 Channel 工厂来创建不同类型的 Channel 。 12345678public T newChannel (EventLoop eventLoop , EventLoopGroup childGroup)&#123; try&#123; Constructor&lt;? extends T&gt; constructor = clazz.getConstructor(EventLoop.class , EventLoopGroup.class); return constructor.newInstance(eventLoop , childGroup); &#125;catch(Throwable t)&#123; throw new ChannelException(\"Unable to create Channel from class \"+clazz,t); &#125;&#125; 指定NioServerSocketChannel 后，需要设置TCP的一些参数，服务端主要是设置TCP的backlog 参数 1.option(ChannelOption.SO_BACKLOG, 1024); ​ backlog指定了内核为此套接口排队的最大连接个数，对于给定的监听套接口，内核需要维护两个队列：未连接队列和已连接队列，根据TCP三路握手过程中三个分节来分隔这两个队列。服务器处于 listen 状态时，收到客户端syn分节时在未完成队列中创建一个新的条目，然后用三路握手的第二个分节即服务器的 syn 相应客户端，此条目在第三个分节到达前（客户端对服务器syn的ack）一直保留在未完成连接队列中，如果三路握手完成，该条目将从未完成连接队列搬到已完成连接队列尾部。当进程调用 accept 时，从已完成队列中的头部取出一个条目给进程，当已完成队列为空时进程将睡眠，直到有条目在已完成队列中才唤醒。什么是syn？ ​ backlog 被规定为两个队列总和的最大值，Netty 设置的默认backlog为100，用户可以修改默认值，这需要根据实际场景和网络状况进行灵活设置。 ​ 服务端启动的最后一步，就是绑定本地端口，启动服务，源代码如下： 1234567891011121314151617181920212223242526private ChannelFuture doBind(final SocketAddress localAddress) &#123; final ChannelFuture regFuture = this.initAndRegister(); final Channel channel = regFuture.channel(); if (regFuture.cause() != null) &#123; return regFuture; &#125; else if (regFuture.isDone()) &#123; ChannelPromise promise = channel.newPromise(); doBind0(regFuture, channel, localAddress, promise); return promise; &#125; else &#123; final AbstractBootstrap.PendingRegistrationPromise promise = new AbstractBootstrap.PendingRegistrationPromise(channel); regFuture.addListener(new ChannelFutureListener() &#123; public void operationComplete(ChannelFuture future) throws Exception &#123; Throwable cause = future.cause(); if (cause != null) &#123; promise.setFailure(cause); &#125; else &#123; promise.registered(); AbstractBootstrap.doBind0(regFuture, channel, localAddress, promise); &#125; &#125; &#125;); return promise; &#125; &#125; 首先创建Channel，它有两个参数：参数1是从父类的NIO线程池中顺序获取一个 NioEventLoop ，它就是服务端用于监听和接收客户端连接的Reactor 线程；参数2是所谓的workerGroup 线程池，它就是处理 IO 读写的 Reactor 线程组 12345678910111213141516final ChannelFuture initAndRegister() &#123; Channel channel = null; try &#123; channel = this.channelFactory.newChannel(); this.init(channel); &#125; catch (Throwable var3) &#123; if (channel != null) &#123; channel.unsafe().closeForcibly(); &#125; return (new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE)).setFailure(var3); &#125; //......&#125; NioServerSocketChannel 创建完成之后，将对它进行初始化，主要有一下三点： 设置 socket 参数和 NioServerSocketChannel 的附加属性 1234567891011121314void init(Channel var1) throws Exception&#123; final Map&lt;ChannelOption&lt;?&gt; , Object&gt; options = options(); synchronized(options)&#123; channel.config().setOptions(options); &#125; final Map&lt;AttributeKey&lt;?&gt; , Object&gt; attrs = attrs(); synchronized(attrs)&#123; for(Entry&lt;AttributeKey&lt;?&gt; , Object&gt; e : attrs.entrySet())&#123; AttributeKey&lt;Object&gt; key = e.getKey(); channel.attr(key).set(e.getValue()); &#125; &#125;&#125; 将 AbstractBootstrap 的 Handler 添加到 NioServerSocketChannel 的 ChannelPipeline 中 将用于服务端注册的 Handler ServerBootstrapAcceptor 添加到 ChannelPipeline 中 到此服务端监听的相关资源已经初始化完毕 最后一步，注册 NioServerSocektChannel 到 Reactor 线程的多路复用器上，然后轮询客户端连接事件 12345678910111213141516171819/*** 我们可以看到这段代码的含义：首先判断是否为 NieEventLoop 自身发起的操作。如果是则不存在并发操作，直接执行 Channel 注册；如果由其它线程发起，则封装成* 一个Task 放入消息队列中异步执行*/public final void register(final ChannelPromise promise)&#123; if(eventLoop.inEventLoop())&#123; register0(promise); &#125;else&#123; try&#123; eventLoop.execute(new Runnable()&#123; public void run()&#123; register0(promise); &#125; &#125;); &#125;catch(Throwable t)&#123; //...... &#125; &#125;&#125; 接下来我们看一下 register0 ( ChannelPromise promise )的实现： 1234567891011121314private void register0(ChannelPromise promise)&#123; try&#123; if(!ensureOpen(promise)) return; doRegister(); registered = true; promise.setSuccess(); pipeline.fireChannelRegistered(); if(isActive()) pipeline.fireChannelActive(); &#125;catch(Throwable t)&#123; //...... &#125;&#125; ​ 将NioServerSocketChannel 注册到 NioEventLoop 的 Selector 上： 1234567protected void doRegister() throws Exception&#123; boolean selected = false; for(;;)&#123; selectionKey = javaChannel().register(eventLoop().selector , 0 , this); //...... &#125;&#125; ​ 我们可以看到注册了 0 到多路复用器上，不监听任何网络操作。这样是有原因的： ​ （1）注册方法是多态的，它既可以被 NioServerSocketChannel 用来监听客户端的连接接入，也可以注册 SocketChannel 用来监听网络读写操作 ​ （2）通过SelectionKey 的 interestOps（int Ops）方法可以方便修改监听操作位。所以才需要返回selectionKey ​ 注册成功之后，出发 ChannelRegistered 事件 12promise.setSuccess();pipeline.fireChannelRegistered(); ​ ChannelRegistered 事件传递完成后，判断 ServerSocketChannel 监听是否成功，如果成功需要触发 NioServerSocketChannel 的 ChannelActive 事件。isActive() 方法也是多态的。如果是服务端，判断监听是否启动；如果是客户端，判断TCP连接是否完成。ChannelActive 事件在 ChannelPipeline 中传递，完成之后根据配置决定是否自动出发 Channel 的读操作 1234567public ChannelPipeline fireChannelActive()&#123; head.fireChannelActive(); if(channel.config().isAutoRead())&#123; channel.read(); &#125; return this;&#125; ​ AbstractChannel 的读操作触发 ChannelPipeline 的读操作，最终调用到HeadHandler 的读方法： 12345678910111213public void read(ChannelHandlerContext ctx)&#123; unsafe.beginRead();&#125;public void beginRead()&#123; if(!isActive())&#123; return ; &#125; try&#123; doBeginRead(); //...... &#125;&#125; ​ 对于不同类型的 Channel 对读操作的准备工作不同，因此，beginRead 也是个多态方法，对于NIO通信，无论是客户端还是服务端，都是要修改网络监听操作位为自身感兴趣的，对于 NioServerSocketChannel 感兴趣的操作是 OP_ACCEPT(16) ，于是要修改注册操作位 12345678protected void doBeginRead() throws Exception&#123; //...... final int interestOps = selectionKey.interestOps(); //只有当监听的操作类型和 Channel 关心的网络事件不一致的时候才需要重新注册操作位，所以增加了&amp;操作的判断 if((interestOps &amp; readInterestOps) == 0 )&#123; selectionKey.interestOps(interestOps | readInterestOps); &#125;&#125; ​ JDK SelectionKey 有4种操作类型： （1）OP_READ = 1&lt;&lt;0； （2）OP_WRITE = 1&lt;&lt;2； （3）OP_CONNECT = 1&lt;&lt;3； （4）OP_ACCEPT = 1&lt;&lt;4 ​ 最后在服务器链路注册成功之后重新将操作位设置为监听客户端的网络连接操作，初始化 NioServerSocketChannel 的代码如下 1234public NioServerSocketChannel(EventLoop eventLoop , EventLoopGroup childGroup)&#123; super(null , eventLoop , childGroup , newSocket() , SelectionKey.OP_ACCEPT); config = new DefaultServerSocketChannelConfig(this , javaChannel().socket());&#125; 搞定！！！","categories":[],"tags":[{"name":"Netty 我有话说","slug":"Netty-我有话说","permalink":"http://wildergao.github.io/tags/Netty-我有话说/"}]},{"title":"并发编程总结三","slug":"并发编程总结三","date":"2018-02-20T13:19:04.000Z","updated":"2018-02-22T07:49:56.000Z","comments":true,"path":"2018/02/20/并发编程总结三/","link":"","permalink":"http://wildergao.github.io/2018/02/20/并发编程总结三/","excerpt":"","text":"线程简介线程的理解现代操作系统调度的最小单元是线程，也加轻量级进程，在一个进程里可以创建多个线程，这些线程拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。 使用多线程的原因 更多的处理器核心 更快的响应时间 更好的变成模型线程优先级现代操作系统基本采用时分的形式调度运行的线程。在java线程中，通过一个整型成员变量priority来控制优先级，对应的方法为 setPriority() ,默认优先级是5，优先级高的线程分配时间片的数量要多余优先级低的线程。线程的状态| 状态名称 | 说明 || ———— | :————————————–: || NEW | 初始状态，线程被构建，但还没有调用start()方法 || RUNNABLE | 运行状态，java线程将操作系统中的就绪和运行两个状态统称为“运行中” || BLOCKED | 阻塞状态，表示线程阻塞于锁 || WAITING | 等待状态，只有当其它线程进行通知或者中断的时候，等待状态的线程才会从wait()中返回 || TIME_WAITING | 超时等待状态，在指定时间内可以自行返回 || TERMINATED | 终止状态，表示当前线程已经执行完毕 | Daemon线程Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。当一个java虚拟机中不存在非Daemon线程的时候，java虚拟机将会退出。一个线程如果要设置为Daemon线程，必须要在这个线程start()之前进行设置。1234567891011121314151617public class Daemon &#123; public static void mian(String[] args)&#123; Thread thread = new Thread(new DaemonRunner(),&quot;DaemonRunner&quot;); thread.setDaemon(true); //设置为Daemon线程 thread.start(); &#125; static class DaemonRunner implements Runnable&#123; public void run()&#123; try&#123; Thread.sleeep(4000); &#125;finally&#123; System.out.println(&quot;Hello world&quot;); &#125; &#125; &#125;&#125; 运行程序之后，发现并没有输出。这是因为main线程和Daemon线程都在运行，main线程结束之后，Daemon就算没有运行结束也会退出。 启动和终止线程构造线程线程对象在构造时需要提供线程需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。 启动线程线程对象在初始化完成之后，调用start()方法可以启用这个线程。 线程中断其它线程通过调用该线程的interrupt()方法对该线程进行中断操作，线程还可以通过isInterrupted()方法来判断该线程是否被中断。注意：在抛出InterruptedException的方法（比如Thread.sleep()）之前，java虚拟机会先将该线程的中断标识清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。12345678910111213141516171819202122232425262728public class Interrupted&#123; static class SleepRunner implements Runnable&#123; public void run()&#123; while(true)&#123; Thread.sleep(1000); &#125; &#125; &#125; static class BusyRunner implements Runnable&#123; public void run()&#123; while(true)&#123;&#125; &#125; &#125; public static void main(String args[])&#123; Thread sleepThread = new Thread(new SleepRunner(),&quot;sleepThread&quot;); sleepThread.setDaemon(true); Thread busyThread = new Thread(new BusyRunner(),&quot;busyThread&quot;); busyThread.setDaemon(true); sleepThread.start(); busyThread.start(); Thread.sleep(5000); sleepThread.interrupt(); busyThread.interrupt(); sleepThread.isInterrupted(); //结果为false busyThread。isInterrupted(); //结果为true &#125;&#125; 线程间的通信线程等待/通知机制等待/通知机制是任何java对象都具备的，因为这些方法被定义在Object类上| 方法名称 | 描述 || ————— | :————————————–: || notify() | 通知一个在对象上等待的线程，使其从wait()方法中返回，而返回的前提是该线程获取到了对象的锁 || notifyAll() | 通知所有等待在该对象的线程 || wait() | 调用该方法会使线程进入WAITING状态，只有等其它线程唤醒或者该线程被中断的时候才会从wait()方法返回，需要注意的是调用wait()方法之后将会释放锁 || wait(long time) | 等待一定的时间自动返回 |等待/通知机制是指当一个线程调用了对象O的wait()方法之后，该线程进入等待状态，只有当其它线程调用notifyAll()或者notify()方法之后，该线程才会从wait()方法中返回，两个线程就通过对象O来进行交互。调用wait()、notify()可以注意的细节： 使用wait()、notify()等方法之前要先对调用对象加锁 调用wait()方法之后，线程状态将从RUNNING变为WAITING，并将当前线程放入对象的等待队列中 notify()和notifyAll()方法调用以后，等待线程依旧不会从wait()方法中返回，需要等notify()方法的线程释放锁之后线程才有机会从wait()放回 管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存12345678910111213141516171819202122232425262728293031public class Piped&#123; public static void main(String[] args)&#123; PipeWriter out = new PipedWriter(); PipedReader in = new PipedReader(); //将输入流和输出流进行连接，否则在使用时会抛出IOException out.connect(in); Thread printThread = new Thread(new Print(in),\"Print\"); printThread.start(); int receive = 0; try&#123; while(receive = System.in.read()) != -1)&#123; out.write(receive); &#125; &#125;finally&#123; out.close(); &#125; &#125; static class Print implements Runnable&#123; private PipedReader in; public Print(PipedReader in)&#123; this.in = in; &#125; public void run()&#123; int receive = 0; while(receive = in.read())!= -1)&#123; System.out.print((char)receive); &#125;catch(IOException ex)&#123; &#125; &#125; &#125;&#125; 可以看到对于Piped类型的流，必须要先进行绑定，调用connect()方法将输入和输出流绑定起来。 ThreadLoacal的使用ThreadLocal即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值比如说线程A设置一个线程ID为A，set(A)，则通过get()方法返回的就是A；线程B设置线程Id为B，则get()方法得到的就是B 有一些关于线程池和线程应用的具体代码在github上，欢迎大家指点迷津https://github.com/WilderGao/ThreadStudy","categories":[],"tags":[{"name":"并发","slug":"并发","permalink":"http://wildergao.github.io/tags/并发/"}]},{"title":"netty 总结一","slug":"netty-总结一","date":"2018-02-18T14:40:47.000Z","updated":"2018-02-19T08:46:40.000Z","comments":true,"path":"2018/02/18/netty-总结一/","link":"","permalink":"http://wildergao.github.io/2018/02/18/netty-总结一/","excerpt":"","text":"Netty 总结一 我们都知道，传统的IO流（BIO）因为是阻塞的，导致性能低下，特别是当多个线程同时处理的时候会导致线程的阻塞，使得服务器的效率大大降低。非阻塞IO流（NIO）相对于传统IO流来说效率上有相应的提升，但是实现步骤太多，我们来看看原生NIO的实现需要多少步骤： ​ ​ 我们可以看到一个简单接收就需要如此复杂的步骤。 ​ Netty是一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持，作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。下面开门见山的看一看Hello World！ ​ 下面代码实现了客户端向服务器发送日期，服务器返回 Hello World在客户端显示： 1、pom.xml 增加依赖12345&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.15.Final&lt;/version&gt;&lt;/dependency&gt; 2、服务器端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * @author:Wilder Gao * @time:2018/2/18 * @Discription：使用netty第一步，hello World篇 */public class HelloServer &#123; Logger logger = LoggerFactory.getLogger(HelloServer.class); private int port; public HelloServer(int port)&#123; this.port = port; &#125; public void bind()&#123; //处理NIO事件的多线程循环器，一个用来接收新来的连接，一个用来处理已经被接收的连接 EventLoopGroup eventLoopGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); //启动NIO配置的服务类 try &#123; //启动NIO服务的配置类 ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(eventLoopGroup, workerGroup) //服务器端选择的Channel是ServerSocketChannel .channel(NioServerSocketChannel.class) //childHandler 在客户端执行的时候才会触发 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new HelloServerHandler()); &#125; &#125;) .option(ChannelOption.SO_BACKLOG, 1024); ChannelFuture future = bootstrap.bind(port).sync(); //服务器监听端口，阻塞模式，直到服务器链路关闭之后main才关闭 future.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; workerGroup.shutdownGracefully(); eventLoopGroup.shutdownGracefully(); &#125; &#125; private class HelloServerHandler extends ChannelInboundHandlerAdapter&#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; //============以下是接收到消息的逻辑处理=============== logger.info(\"接收到客户端发来的消息\"); //接收的消息也是ByteBuf 格式，将这种格式转换为字符串 ByteBuf byteBuf = (ByteBuf) msg; byte[] result = new byte[byteBuf.readableBytes()]; byteBuf.readBytes(result); String receiveString = new String(result,\"utf-8\"); logger.info(\"内容为\"+receiveString); //释放资源 byteBuf.release(); //===========以下是返回消息的逻辑处理=============== String response = \"Hello world\"; //发送消息时一定要将它打包成ByteBuf 格式 ByteBuf encode = ctx.alloc().buffer(4 * response.length()); encode.writeBytes(response.getBytes()); ctx.writeAndFlush(encode); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; logger.error(\"===========出现异常========\"); cause.printStackTrace(); ctx.close(); &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; ctx.flush(); &#125; &#125; public static void main(String[] args) &#123; new HelloServer(8080).bind(); &#125;&#125; 3、客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * @author:Wilder Gao * @time:2018/2/18 * @Discription：hello world服务器端 */public class HelloClient &#123; Logger logger = LoggerFactory.getLogger(HelloClient.class); /** * 连接服务器端 * @param ip * @param port */ public void connect(String ip , int port)&#123; //客户端可以只使用一个EventLoopGroup ， 用来进行对服务器的连接、发送和接收信息 EventLoopGroup clientGroup = new NioEventLoopGroup(); //客户端使用BootStrap try &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(clientGroup) //服务器端选择的Channel为SocketChannel .channel(NioSocketChannel.class) .option(ChannelOption.SO_KEEPALIVE , true) //handler 方法在初始化时就会执行 .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new LineBasedFrameDecoder(1024)) .addLast(new StringDecoder()) .addLast(new ClientHandler()); &#125; &#125;); ChannelFuture future = bootstrap.connect(ip, port).sync(); future.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; clientGroup.shutdownGracefully(); &#125; &#125; private class ClientHandler extends ChannelInboundHandlerAdapter&#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ByteBuf byteBuf = (ByteBuf) msg; byte[] result = new byte[byteBuf.readableBytes()]; byteBuf.readBytes(result); String receiveString = new String(result,\"utf-8\"); logger.info(\"=======服务器端返回内容来了======\\n\"+receiveString); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; Date date = new Date(); SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\"); //连接成功之后向服务器发送消息 String message = format.format(date); ByteBuf encode = ctx.alloc().buffer(4 * message.length()); encode.writeBytes(message.getBytes()); ctx.writeAndFlush(encode); &#125; //产生异常的处理情况 @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; //关闭Channel ctx.writeAndFlush(Unpooled.EMPTY_BUFFER) .addListener(ChannelFutureListener.CLOSE); &#125; &#125; public static void main(String[] args) &#123; new HelloClient().connect(\"127.0.0.1\",8080); &#125;&#125; 4、核心组件介绍EventLoop​ EventLoop 定义了处理在连接过程中发生的事件的核心抽象。一个EventLoopGroup 包含一个或多个EventLoop ，并且EventLoop 提供了一种迭代用于检索清单中的下一个EventLoop。每个Channel 都会分配到一个EventLoop ，用于处理该Channel 所有的事件。 一个Channel 使用EventLoop 进行注册 ， 而一个EventLoop 会对应多个Channel 一个EventLoop 在生命周期中将会被绑定到一个专有的Thread 上，这个专有的线程处理该EventLoop 所有的事件 Channel​ 基础的IO操作，比如 read、bind、connect 都依赖于底层网络传输所提供的原语，在Java 网络编程中，这些都依赖于 “Socket” ，而Netty 极大简化了直接与Socket 进行操作的复杂性。我对Channel 的理解就是将它看成是一个连接的载体，基础的读写操作将由Channel 建立起连接。 ​ 此外，Channel 还是很多类的父类 EmbeddedChannel、LocalServerChannel、NioDatagramChannel、NioSctpChannel、NioSocketChannel等。 ChannelFuture​ Netty 中所有的IO操作都是异步的，不会立即返回，因此提供了ChannelFuture ，其addListener 方法可以注册一个ChannelFutureListener ，当操作完成时，不管成功还是失败均会被通知。在并发编程Executor 框架中，也有类似于ChannelFuture 的 Future ，通过它的get() 方法可以得知该线程执行任务的结果。 ChannelHandlerChannelHandler 可以说是最重要的组件，处理进站和出站数据的用户逻辑都将存放在这里。常用的使用方法就是继承ChannelHandler 的子接口 ChannelInboundHandler ，ChannelFuture 可以用于几乎任何类型的操作，如发送数据、处理抛出的异常等。 ChannelPipeline​ ChannelPipeline为ChannelHandler链提供了一个容器并定义了用于沿着链传播入站和出站事件流的API。当创建Channel时，会自动创建一个附属的ChannelPipeline。ChannelHandlers按照如下步骤安装在ChannelPipeline中。 ChannelInitializer 通过BootStrap 进行注册 当调用 initChannel() 方法时，ChannelInitializer 会向管道中注册一组自定义的ChannelHandler 当操作完成时，ChannelInitializer 将会从管道中自动删除 ChannelHandler可被当做放置任何代码的容器，用于处理到达并通过ChannelPipeline的事件或者数据，数据可以沿着处理链进行传递。 ​ 当事件从客户端移动至服务端时称为出站，反之称为入站。并且入站处理器和出站处理器可共存于同一个管道中，当读取入站数据或事件时，将会从管道的头部开始传递到第一个入站处理器，然后传递至下一个处理器直至管道的尾部，此时数据处理结束。当出站时，沿着处理链直到管道的头，然后进行网络传输。 5、TCP粘包问题​ TCP 是个 “流” 协议，所谓流就是没有界限的一串数据，期间并没有分界线。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆成多个包进行发送，多个小的包也可能被封装成一个大的数据包进行发送，这就是所谓的TCP 粘包问题。 ​ Netty 解决TCP 的粘包问题尤为简单，有多种已经实现好的ChannelHandler 为我们解决粘包问题，使用的时候只要在ChannelPipeline 管道中加入相应的解码器即可，我们来看看三种常用的解码器： LineBasedFrameDecoder 解码器，按照 \\n、\\r\\n 进行解码 12345678.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new LineBasedFrameDecoder(1024)) .addLast(new StringDecoder()) .addLast(new ClientHandler()); &#125; &#125;); DelimiterBasedFrameDecoder 分隔符解码器，自己设定要用什么符号来划分 12ByteBuf delimiter = Unpooled.copiedBuffer(\"$_\".getBytes());socketChannel.pipeline().addLast(new DelimiterBasedFrameDecoder（1024,delimiter）);//1024为单条消息的最大长度 FixedLengthFrameDecoder 定长解码器，按照固定的长度进行解码 1socketChannel.pipeline().addLast(new FixedLengthFrameDecoder(200));","categories":[],"tags":[{"name":"Netty 我有话说","slug":"Netty-我有话说","permalink":"http://wildergao.github.io/tags/Netty-我有话说/"}]},{"title":"Lambda表达式常见例子","slug":"Lumbda表达式常见例子","date":"2018-02-12T14:09:28.000Z","updated":"2018-02-13T13:26:06.000Z","comments":true,"path":"2018/02/12/Lumbda表达式常见例子/","link":"","permalink":"http://wildergao.github.io/2018/02/12/Lumbda表达式常见例子/","excerpt":"","text":"Lambda 表达式常见例子用Lambda实现Runnable使用 ()-&gt;{ }代码块代替整个匿名类 1234567//不使用Lambda表达式new Thread(new Runnable()&#123; @Override public void run()&#123; System.out.println(\"Before Java8, too much code for too little to do\"); &#125;&#125;).start(); 12345//使用Lambda表达式new Thread(()-&gt;&#123; System.out.println(\"Before Java8, too much code for too little to do\");&#125;).start();//这里的花括号可以省略，有多个语句时就需要写花括号 如果你的方法接收两个参数，那么可以这么写： 12//可以省略int(int even,int odd) -&gt; even + odd 用Lambda表达式进行事件处理12345678// 不使用Lambda表达式JButton show = new JButton(\"Show\");show.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println(\"Event handling without lambda expression is boring\"); &#125;&#125;); 123show.addActionListener((e)-&gt;&#123; System.out.println(\"Event handling without lambda expression is boring\");&#125;); 用Lambda表达式对列表进行迭代12345// 不使用Lambda表达式List features = Arrays.asList(\"Lambdas\", \"Default Method\", \"Stream API\", \"Date and Time API\");for (String feature : features) &#123; System.out.println(feature);&#125; 123456//使用Lambda表达式List features = Arrays.asList(\"Lambdas\", \"Default Method\", \"Stream API\", \"Date and Time API\");features.forEach((n)-&gt;System.out.println(n));//也可以使用Java 8特殊的双引号::features.forEach(System.out::println); 用lambda表达式和函数式接口PredicatePredicate 在java.util工具类中，我的理解就是相当于一个判断格式，引用别人博客中的话就是说 使用 java.util.function.Predicate 函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更多的动态行为。 123456789101112131415161718192021222324252627282930public void filter(List&lt;String&gt; list , Predicate&lt;String&gt; condition)&#123; //for(String name:list)&#123; //if(condition.test(name)) // System.out.println(name+\" \"); // &#125; //这里的循环还有更简便的方法，就是采用Stream API中的过滤方法 list.stream().filter((name)-&gt;(condition.test(name))).forEach((name)-&gt;&#123; System.out::println&#125;);&#125;public static void main(args[])&#123; List languages = Arrays.asList(\"Java\", \"Scala\", \"C++\", \"Haskell\", \"Lisp\"); System.out.println(\"Languages which starts with J :\"); filter(languages, (str)-&gt;str.startsWith(\"J\")); System.out.println(\"Languages which ends with a \"); filter(languages, (str)-&gt;str.endsWith(\"a\")); System.out.println(\"Print all languages :\"); filter(languages, (str)-&gt;true); System.out.println(\"Print no language : \"); filter(languages, (str)-&gt;false); System.out.println(\"Print language whose length greater than 4:\"); filter(languages, (str)-&gt;str.length() &gt; 4);&#125; 另外，Predicate 接口也允许进行多重条件的测试： 它提供类似于逻辑操作符AND和OR的方法，名字叫做and()、or()和xor()，用于将传入 filter() 方法的条件合并起来。 12345678//使用了两个Predicate，用and作为连接，表示只有符合这两个条件的元素才会被打印出来 public static void filter(List&lt;String&gt; languane , Predicate&lt;String&gt; predicate , Predicate&lt;String&gt; predicate2)&#123; languane.stream().filter(predicate.and(predicate2)).forEach( (name)-&gt;&#123; System.out.println(name+\" \"); &#125; ); &#125; 用Lambda 表达式的Map和Reduce函数式编程概念map。它允许你将对象进行转换。 12345678910//不使用Lambda表达式为每个订单加上12%的税List costBeforeTax = Arrays.asList(100,200,300);for(Integer cost : costBeforeTax)&#123; double price = cost + 0.12*cost; System.out.println(price);&#125;//使用Lambda表达式List costBeforeTax = Arrays.asList(100,200,300);costBeforeTax.stream().map((cost)-&gt;cost+0.12*cost).forEach(System.out::println); Map和Reduce操作是函数式编程的核心操作，因为其功能，reduce 又被称为折叠操作。另外，reduce 并不是一个新的操作，你有可能已经在使用它。SQL中类似 sum()、avg() 或者 count() 的聚集函数，实际上就是 reduce 操作，因为它们接收多个值并返回一个值。流API定义的 reduceh() 函数可以接受lambda表达式，并对所有值进行合并。IntStream这样的类有类似 average()、count()、sum() 的内建方法来做 reduce 操作，也有mapToLong()、mapToDouble() 方法来做转换。 12345678910111213//不使用Lambda表达式计算总价和税后价List costBeforeTax = Arrays.asList(100,200,300);double total = 0 ;for(Integer cost : costBeforeTax)&#123; double price = cost + 0.12*cost; total += price;&#125;System.out.println(\"total = \"+total);//使用Lambda表达式中的reduce计算总价和税后价List costBeforeTax = Arrays.asList(100,200,300);double total = costBeforeTax.stream().map((cost)-&gt;cost+0.12*cost).reduce((sum , cost) -&gt; sum + cost).get();System.out.println(\"total = \"+total); 使用dictinct() 方法来对集合进行去重12345List&lt;Integer&gt; numbers = Arrays.asList(9, 10, 3, 4, 7, 3, 4);List&lt;Integer&gt; distinct = numbers.stream().map(i-&gt;i*i).distinct().collect(Collectors.toList());//打印number：[9, 10, 3, 4, 7, 3, 4]//打印distinct：[81, 100, 9, 16, 49] 计算集合元素中的最大值、最小值、总和和平均值IntStream、LongStream 和 DoubleStream 等流的类中，有个非常有用的方法叫做 summaryStatistics() 。可以返回 IntSummaryStatistics、LongSummaryStatistics 或者 DoubleSummaryStatistic s，描述流中元素的各种摘要数据。在本例中，我们用这个方法来计算列表的最大值和最小值。它也有 getSum() 和 getAverage() 方法来获得列表的所有元素的总和及平均值。 1234567//获取数字的个数、最小值、最大值、总和以及平均值List&lt;Integer&gt; primes = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);IntSummaryStatistics stats = primes.stream().mapToInt((x) -&gt; x).summaryStatistics();System.out.println(\"Highest prime number in List : \" + stats.getMax());System.out.println(\"Lowest prime number in List : \" + stats.getMin());System.out.println(\"Sum of all prime numbers : \" + stats.getSum());System.out.println(\"Average of all prime numbers : \" + stats.getAverage()); 对Lambda 注意的事项 Lambda 表达式可以使用方法引用，仅当该方法不会修改Lambda表达式提供的参数；若对参数有任何修改，则必须键入完整的Lambda表达式 1234list.forEach(n -&gt; System.out.println(n)); list.forEach(System.out::println); // 使用方法引用list.forEach((String s) -&gt; System.out.println(\"*\" + s + \"*\")); //修改字符串s Lambda方法在编译器内部被翻译成私有方法，并派发 invokedynamic 字节码指令来进行调用。 lambda表达式有个限制，那就是只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量。 1234567List&lt;Integer&gt; primes = Arrays.asList(new Integer[]&#123;2, 3,5,7&#125;);int factor = 2;primes.forEach(element -&gt; &#123; factor++; &#125;);//对外部变量factor进行修改，将会出现错误//但是如果只是访问外部变量而不做修改则被允许primes.forEach((element)-&gt;System.out.println(element*factor) );","categories":[],"tags":[{"name":"Java小技巧","slug":"Java小技巧","permalink":"http://wildergao.github.io/tags/Java小技巧/"}]},{"title":"并发编程总结四","slug":"并发编程总结四","date":"2018-02-12T08:17:18.000Z","updated":"2018-09-16T11:15:07.154Z","comments":true,"path":"2018/02/12/并发编程总结四/","link":"","permalink":"http://wildergao.github.io/2018/02/12/并发编程总结四/","excerpt":"","text":"Executor框架结构 任务：包括被执行任务需要实现的接口：Runnable 接口或者 Callable 接口 任务的执行：继承自Executor的ExecutorService接口。Executor 框架有两个关键类实现了ExecutorService 接口，分别是ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 异步计算的结果：包括接口Furure 和 实现Future 接口的FutureTask 实现流程 主线程首先要创建实现Runnable 或者 Callable 接口的任务对象 然后可以把Runnable 对象直接交给ExecutorService 执行：ExecutorService.execute(Runnable run) ；或者将Runnable 对象或者 Callable 对象提交给ExecutorService 执行：ExecutorService.submit(Callable a) 如果执行submit() 方法，则会返回一个FutureTask 对象 最后，主线程可以执行FutureTask.get() 方法等待任务执行完成。主线程也可以执行 FutureTask.cancel( boolean mayInterruptIfRunning) 来取消此任务的执行 Executor 成员ThreadPoolExecutorExecutors 可以创建三种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool、CachedThreadPool FixedThreadPool 被称为可重用固定线程数的线程池，源代码如下 1234public static ExecutorService newFixedThreadPool(int nThreads)&#123; return new ThreadPoolExecutor(nThreads,nThreads,0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;);&#125; 其中参数依次为：corePoolSize 和 maximumPoolSize ，keepAliveTime设置为 0L 表示有空闲线程等待接收新任务的时间为0，也就是说一旦有空闲的线程就会被立即终止，LinkedBlockingQueue 是一个无界链式队列，当执行的任务数超过corePoolSize 时，后面的任务将会加入到队列中，等其它任务执行完成之后再从队列中拿取任务执行。 对FixedThreadPool 的说明如下： 1231、如果当前运行的线程数少于corePoolSize ，则创建新线程来执行任务2、当前线程数量等于corePoolSize 时，将任务加入LinkedBlockingQueue3、线程执行完任务之后，会在循环中反复从LinkBlickingQueue 获取任务来执行 SingleThreadExecutor 它和FixedThreadPool 不一样的地方在于它是使用单个worker线程的Executor，也就是nThread为 1 1234public static ExecutorService newSingleThreadExecutor()&#123; return new ThreadPoolExecutor(1,1,0L,TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;);&#125; 对SingleThreadExecutor 的说明如下： 1231、如果当前运行的线程数为0，则创建一个新线程来执行任务2、当前线程池有一个线程在运行，将任务加入到LinkedBlockingQueue中3、线程中任务执行完之后会在一个无限循环中反复从LinkedBlockingQueue 获取任务来执行 CachedThreadPool 是一个会根据需要创建新线程的线程池 1234public static ExecutorService newCacheThreadPool()&#123; return new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.MILLISECONDS, new SynchronousQueue&lt;Runnable&gt;);&#125; CachedThreadPool 使用没有容量的SynchronousQueue 作为线程池的工作队列，但CachedThreadPool 的mximumPool 大小是Integer.MAX_VALUE是无界的。这就意味着：如果主线程提交任务的速度高于maxmumiPool中线程处理任务的速度时，CacheThreadPool会不断创建新线程。 对CachedThreadPool 的说明如下： 1231、首先执行SychronousQueue.poll(keepAliveTime , TimeUnit.NANOSECONDS)，判断当前有没有空闲的线程在执行poll()方法，如果有的话主线程执行offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行，execute()方法执行结束2、如果没有空闲线程，或者初始maximumPool为空时，则创建线程执行execute()方法3、新创建的线程执行完之后，会执行poll()方法，空闲线程等待60s，如果在这60s没有新任务交给这个线程执行，则这个线程将会被终止 ScheduledThreadPoolExecutorScheduledThreadPoolExecutor 主要用来在给定的延迟之后运行任务，或者定期执行任务。使用的是DelayQueue ，它是一个支持延时获取元素的无界阻塞队列，队列使用PriorityQueue 来实现，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。 执行主要分为两部分： 当调用scheduleAtFixedRate() 或者 scheduleWithFixedDelay() 方法的时候，会向DelayQueue 添加一个视线了RunnableScheduledFuture 接口的ScheduledFutureTask 线程池中的线程从DelayQueue 中获取ScheduledFutureTask，然后执行任务 ScheduledThreadPoolExecutor 的实现： ScheduledFutureTask 主要包含3个成员变量： long 型成员变量time，表示这个任务将要被执行的具体时间 long 型成员变量sequenceNumber ，表示这个任务被添加到ScheduledThreadPoolExecutor 中的序号 long 型成员变量period，表示任务执行的间隔周期 DelayQueue 中封装的PriorityQueue 会对队列中的ScheduledFutureTask 进行排序，time小的排在前面执行，假如time 相同，就比较sequenceNumber ，小的排在前面，表示先提交的任务先被执行。 执行周期任务的过程： 12341、线程1从DelayQueue 中获取已到期的ScheduledFutureTask（DelayQueue.take()），到期任务是指task中的time大于当前时间2、线程1执行这个task3、线程1修改ScheduledFutureTask 的time变量为下次将要被执行的时间4、线程1把这个修改time之后的ScheduledFutureTask放回DelayQueue中 FutureTaskFutureTask 实现了Future 和 Runnable 接口，因此FutureTask 可以交给Executor执行，也可以直接FutureTask.run()，FutureTask有三种状态，分别是：未启动、已启动、已完成。 当FutureTask 处于未启动或者已启动状态时，执行get()方法会导致调用线程阻塞；处于已完成状态时调用会立刻返回结果或者抛出异常 处于未启动状态时，调用cancel() 方法将导致任务永远不会执行；处于已启动状态时，当执行FutureTask.cancel(true) 即使正在执行的任务也会遭到停止，当执行FutureTask.cancel(false) 时正在执行的任务会继续执行，还没执行的任务将不再执行 FutureTask 的使用 当一个线程需要等待另一个线程把某个任务执行完之后它才能继续执行，此时可以使用FutureTask 123456789101112131415161718192021222324252627282930313233343536373839404142package chapter10;import java.util.concurrent.Callable;import java.util.concurrent.CancellationException;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;import java.util.concurrent.ExecutionException;import java.util.concurrent.Future;import java.util.concurrent.FutureTask;public class ConcurrentTask &#123; private final ConcurrentMap&lt;Object, Future&lt;String&gt;&gt; taskCache = new ConcurrentHashMap&lt;Object, Future&lt;String&gt;&gt;(); private String executionTask(final String taskName) throws ExecutionException, InterruptedException &#123; while (true) &#123; Future&lt;String&gt; future = taskCache.get(taskName); //1.1,2.1 if (future == null) &#123; Callable&lt;String&gt; task = new Callable&lt;String&gt;() &#123; public String call() throws InterruptedException &#123; //...... return taskName; &#125; &#125;; //1.2创建任务 FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(task); future = taskCache.putIfAbsent(taskName, futureTask); //1.3 if (future == null) &#123; future = futureTask; futureTask.run(); //1.4执行任务 &#125; &#125; try &#123; return future.get(); //1.5,2.2线程在此等待任务执行完成 &#125; catch (CancellationException e) &#123; taskCache.remove(taskName, future); &#125; &#125; &#125;&#125; 当两个线程试图同时执行同一个任务时，如果Thread 1执行1.3 后 Thread 2执行 2.1 ，那么接下来Thread 2 将在2.2 等待，直到Thread 1 执行完1.4 后Thread 才能从2.2 返回。 参考《并发编程的艺术》第10章","categories":[],"tags":[{"name":"并发","slug":"并发","permalink":"http://wildergao.github.io/tags/并发/"}]},{"title":"SpringBoot实现限制IP访问次数","slug":"SpringBoot实现限制IP访问次数","date":"2018-02-06T14:21:43.000Z","updated":"2018-02-06T14:23:54.000Z","comments":true,"path":"2018/02/06/SpringBoot实现限制IP访问次数/","link":"","permalink":"http://wildergao.github.io/2018/02/06/SpringBoot实现限制IP访问次数/","excerpt":"","text":"SpringBoot实现限制ip访问次数有时候存在着一些恶意访问的情况，为了阻止这种情况的发生，我们可以写一个拦截器，当某个IP的访问在单位时间内超过一定的次数时，将禁止他继续访问。在这里我们使用了SpringBoot搭配注解来使用除了springboot需要的依赖之外，我们还需要加上Aspect依赖123456&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; 我们可以自定义一个注解，里面填入单位时间长度和单位时间访问的最大次数123456789101112131415161718192021222324252627 package com.example.web.demo.test;import org.springframework.core.Ordered;import org.springframework.core.annotation.Order;import java.lang.annotation.*;/** * @Author:高键城 * @time： * @Discription： */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Documented@Order(Ordered.HIGHEST_PRECEDENCE)public @interface RequestLimit &#123; /** * 允许访问的最大次数 */ int count() default Integer.MAX_VALUE; /** * 时间段，单位为毫秒，默认值一分钟 */ long time() default 60000;&#125; 接下来我们要定义一个异常类123456789101112131415161718package com.example.web.demo.test;/** * @Author:高键城 * @time： * @Discription： */public class RequestLimitException extends Exception &#123; private static final long serialVersionUID = 1364225358754654702L; public RequestLimitException()&#123; super(&quot;HTTP请求超出设定的限制&quot;); &#125; public RequestLimitException(String message)&#123; super(message); &#125;&#125; 有了注解之后，我们要对注解实行一些相应的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 package com.example.web.demo.test;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import javax.servlet.http.HttpServletRequest;import java.util.HashMap;import java.util.Map;import java.util.Timer;import java.util.TimerTask;/** * @author Administrator * @time： * @Discription： */@Aspect@Componentpublic class RequestLimitContract &#123; private static final Logger logger = LoggerFactory.getLogger(&quot;requestLimitLogger&quot;); private Map&lt;String , Integer&gt; redisTemplate = new HashMap&lt;&gt;(); @Before(&quot;within(@org.springframework.stereotype.Controller *) &amp;&amp; @annotation(limit)&quot;) public void requestLimit(final JoinPoint joinPoint , RequestLimit limit) throws RequestLimitException &#123; try &#123; Object[] args = joinPoint.getArgs(); HttpServletRequest request = null; for (int i = 0; i &lt; args.length; i++) &#123; if (args[i] instanceof HttpServletRequest) &#123; request = (HttpServletRequest) args[i]; break; &#125; &#125; if (request == null) &#123; throw new RequestLimitException(&quot;方法中缺失HttpServletRequest参数&quot;); &#125; String ip = request.getLocalAddr(); String url = request.getRequestURL().toString(); String key = &quot;req_limit_&quot;.concat(url).concat(ip); if (redisTemplate.get(key) == null || redisTemplate.get(key) == 0) &#123; redisTemplate.put(key, 1); &#125; else &#123; redisTemplate.put(key, redisTemplate.get(key) + 1); &#125; int count = redisTemplate.get(key); if (count &gt; 0) &#123; //创建一个定时器 Timer timer = new Timer(); TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; redisTemplate.remove(key); &#125; &#125;; //这个定时器设定在time规定的时间之后会执行上面的remove方法，也就是说在这个时间后它可以重新访问 timer.schedule(timerTask, limit.time()); &#125; if (count &gt; limit.count()) &#123; logger.info(&quot;用户IP[&quot; + ip + &quot;]访问地址[&quot; + url + &quot;]超过了限定的次数[&quot; + limit.count() + &quot;]&quot;); throw new RequestLimitException(); &#125; &#125;catch (RequestLimitException e)&#123; throw e; &#125;catch (Exception e)&#123; logger.error(&quot;发生异常&quot;,e); &#125; &#125;&#125; @before 注解代表在请求发送到控制器之前会先来到这里执行相应的内容，within里面的书写表示写在控制器上方并且有对应注解的控制器会来到这里。 在获得ip和对应的url之后将它作为一个key，存放到map中，假如map中已经存在了这个key，那么多产生一个时间处理器，当时间超过注解书写的单位时间之后又会将这个key从map中移走。 假如访问的次数超过了限制，将会抛出异常说明访问次数过多 最后在使用控制器的时候加上对应的注解即可12345678@Controllerpublic class testController&#123; @RequestMapping(&quot;/hello&quot;) @RequestLimit(count=10,time=60000) public String test(HttpServletRequest request)&#123; return &quot;hello&quot;; &#125;&#125;","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://wildergao.github.io/tags/SpringBoot/"}]},{"title":"并发编程总结一","slug":"并发编程总结一","date":"2018-02-06T13:52:44.000Z","updated":"2018-02-06T14:26:12.000Z","comments":true,"path":"2018/02/06/并发编程总结一/","link":"","permalink":"http://wildergao.github.io/2018/02/06/并发编程总结一/","excerpt":"","text":"java关于并发的总结之一多线程不一定快从大多数运行实力来看（这里不做演示），当并发执行的操作累加不超过百万次的时候，速度并不会比串行执行累加操作要快（也就是单线程）。这是因为多线程的创建、线程之间的操作时会有上下文切换的情况，这些情况都会有时间的开销。所以当操作次数不大的时候可以不用考虑多线程。 死锁1234567891011121314151617181920212223242526272829303132private void deadLock()&#123; Thread t1 = new Thread(new Runnable()&#123; @Override public void run()&#123; synchronized(A)&#123; try&#123; Thread.currentThread().sleep(2000); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; synchronized(B)&#123; System.out.println(&quot;1&quot;); &#125; &#125; &#125; &#125;; Thread t2 = new Thread(new Runnable()&#123; @Override public void run()&#123; synchronized(B)&#123; try&#123; Thread.currentThread().sleep(1000); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; synchronized(A)&#123; System.out.println(&quot;2&quot;); &#125; &#125; &#125; &#125;;&#125; 当运行上面的代码之后，我们会发现，t1拿到锁Ａ，之后等待t2释放锁Ｂ，t2拿到锁Ｂ，等待t1释放锁Ａ，这样就产生了两者都拿不到锁的情况，也就是所谓的死锁。 避免死锁的几个常见方法 避免一个线程同时获取多个锁 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源 尝试使用定时锁，使用lock.tryLock(timeout) 来代替使用内部锁机制 对于数据库锁，加锁和解锁必须在同一个数据库链接里，否则会出现解锁失败的情况 volatile 的应用首先来看一些CPU术语的定义| 术语 | 术语描述 || —– | :————————————–: || 内存屏障 | 是一组处理器指令，用于实现对内存操作的顺序限制 || 缓冲行 | CPU告诉缓存中可以分配的最小存储单位。处理器填写缓存行时会夹在整个缓存行，现代CPU需要执行几百次CPU指令 || 原子操作 | 不可中断的一个或一系列操作 || 缓存行填充 | 当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个高速缓存行到适当的缓存 || 缓存命中 | 如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存中读取 || 写命中 | 当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存 || 写缺失 | 一个有效的缓存行被写入到不存在的内存区域 | volatile 的两条实现原则 当前处理器缓存行的数据写回到系统内存 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效 1instance = new SIngleton(); //这个变量被volatile修饰 //将它转变成汇编代码后会发现，和普通变量不同的是多了后面一行汇编代码lock add1$0x0,(%esp)我们要注意的就是这个lock，因为这个lock，便会执行上面的两条实现原则由此可知，当被volatile修饰的时候，转变为汇编代码时会有lock前缀的一行汇编代码。在多处理器下，为保证各个处理器的缓存是一致的，就会实现缓存一致性原则。这里用一个小例子来叙述：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用volatile修饰的变量a1起始值为3,则各个处理器将会缓存这个值为3地址,这个时候当处理器1将a1的值修改为4的时候，正在修改的这个时候，将会把对应的缓存锁住，其他处理器暂时不能修改这片缓存上的值。修改成功后释放锁，并将缓存行的数据写回到系统内存中。这个时候，处理器2和处理器3嗅探总线上传播的数据，并检查自己缓存的值对应是否相同，当发现自己内存上对应的值被修改的时候，就会将当前缓存行设置成无效状态，重新从系统中把数据读取到处理器缓存里。 synchronized 的应用对象头 对象自身的运行时数据如：哈希吗（HashCode）、GC分代年龄(Generational GC Age)等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，简称“Mark Word” 如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2Word存储对象头。 指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度。 对象头信息是与对象自身定义的数据无关的额外存储成本。它会根据对象的状态复用自己的存储空间。例如：在32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32bit空间中的25bit用于存储对象哈希吗（HashCode），4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0 ​ synchronized 也就是所说的重量级锁，在javaSE 1.6之后引入了“偏向锁”和“轻量级锁”，如今锁一共有四种状态：无状态锁、偏向锁状态、轻量级锁和重量级锁状态。 偏向锁&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大多数情况下，锁不仅不存在多线程竞争，而且总是有同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块的时候并获得锁时，会在对象头和栈桢中的锁记录里存储锁偏向的线程ＩＤ，以后该线程在进入和推出同步块的时候不需要进行ＣＡＳ操作来加锁和解锁，只要简单测试一下对象头的Ｍark Ｗord里是否储存着指向当前线程的偏向锁。如果测试成功则获得了锁，如果测试失败则要查看Ｍark Ｗord中标识是否设置为偏向锁，如果是则尝试用ＣＡＳ将锁指向当前线程，如果不是则升级为竞争锁。 轻量级锁 加锁：线程在进行同步块之前，ＪＶＭ会现在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Ｍark Ｗord复制到锁记录中，然后将线程尝试使用ＣＡＳ将对象头中的Ｍark Ｗord替换为指向锁记录的指针。如果成功则当前线程获得锁，否则表示其他线程在竞争锁，当前线程便尝试使用自旋来获取锁。 解锁 解锁时，会使用原子的ＣＡＳ操作将对象头复制到锁记录的操作替换到对象头，如果成功就表示没有竞争发生，如果失败则表示当前锁存在竞争，锁就会膨胀成重量级锁。 这是我的第一个总结，最近再看《java并发编程的艺术》这本书，根据我自己的理解做出的总结，可能有些理解会有一点错误，希望各位大牛们看完后可以在评论区中指出我的理解错误，谢谢~~ ​​​​参考《java并发编程的艺术》","categories":[],"tags":[{"name":"并发","slug":"并发","permalink":"http://wildergao.github.io/tags/并发/"}]},{"title":"并发编程总结二","slug":"并发编程总结二","date":"2018-02-05T15:11:45.000Z","updated":"2018-08-19T07:59:30.000Z","comments":true,"path":"2018/02/05/并发编程总结二/","link":"","permalink":"http://wildergao.github.io/2018/02/05/并发编程总结二/","excerpt":"","text":"java关于并发的总结之二内存模型基础&nbsp;&nbsp;&nbsp;&nbsp;在并发编程中，需要处理两个关键问题：线程之间如何通信以及线程之间如何同步。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。&nbsp;&nbsp;&nbsp;&nbsp;java的并发采用的是共享内存模型，java线程之间的通信总是隐式的进行，整个通信过程对程序员完全透明。 java内存模型的抽象结构java线程之间的通信由java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入合适对另一个线程可见。抽象角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本（但本地内存仅是一个抽象概念，并不真实存在，这么说是模拟了一种存储方式）。如果线程之间要进行通信的话，必须经历下面两个步骤（这里的通信是指线程A写入的数据会被线程B读取到）: 线程A把本地内存A中更新过的共享变量刷新到主内存中去 线程B到主内存中读取线程A之前已更新过的共享变量。 从源代码到指令序列的重排序重排序分为三种类型： 编译器优化的重排序。 指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 1属于编译器重排序，2和3属于处理器重排序。重排序会导致多线程程序出现内存可见性问题，所以对于编译器，JMM的重排序规则会禁止某些特定类型的重排序。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令时插入特定类型的内存屏障指令，通过内存屏障来禁止特定类型的处理器重排序。 并发编程模型的分类写缓冲区 优点：写缓冲区可以保证指令流水线持续运行，同时通过以批处理的方式刷新写缓冲区，以及合并写缓冲区对同一内存地址的多次写，减少对内存总线的占用。 缺点：只对当前处理器可见，也就是说处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的顺序一致。比如说：12345678910&#123; &#123; a = 1 //步骤1 x = b; //步骤2 &#125; &#123; b = 2; y = a; &#125;&#125; 当线程A运行上半部分，线程B运行下半部分。我们希望得到的结果是x=2，y=3，但因为处理器允许写读重排序（Store-Load重排序），也就是说步骤1和步骤2的运行顺序会发生改变，所以有可能发生一下的情况：内存先初始化了变量a和b，初始化之后a和b赋值为0，这时候步骤1和2进行了重排序，所以x得到的是初始化为0的b，同样y也得到的是0，x和y赋值之后，a=1和b=2才被写入到主内存中。出现这个问题的关键原因就是写缓冲区仅对自己的处理器可见，导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此都会允许写-读操作重排序。 处理器\\规则 Load-Load Load-Store Store-Store Store-Load 数据转换 SPARC-TSO N N N Y N x86 N N N Y N IA64 Y Y Y Y N SPARC-TSO Y Y Y Y N 可以看到，不同的处理器都允许写-读重排序，也就是Store-load重排序，对数据转换都不允许，这和上文提到的数据依赖性有关 为了避免这种错误的发生，保证内存可见性，变了一起在生成指令序列的适当位置会插入内存屏障指令来进行特定类型的处理器重排序。JMM把内存屏障分为四类: LoadLoad Barriers：确保Load1数据的装载先于Load2以及所有后续装载指令 StoreStore Barriers：确保Store1的数据对其他处理器可见（会使缓存行无效，并刷新到内存中）先于Store2及所有后续存储指令的装载 LoadStore Barriers：确保Load1数据装载先于Store2及所有后续存储指令刷新到内存 StoreLoad Barriers：确保Store1数据对其他处理器可见（刷新到内存，并且其他处理器的缓存行无效）先于Load2及所有后续装载指令的装载。该指令会使得该屏障之前的所有内存访问指令完成之后，才能执行该屏障之后的内存访问指令。 happens-before简介在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happ-before关系。两个操作可以是在一个线程之内，也可以是在不同线程之间。与程序员密切相关的happens-before规则如下： 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读 传递性：A happens-before B，B happens-before C，则A happens-before C 注意： 两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行。仅仅要求前一个执行的结果对后一个操作可见。也就是说，假如 A happens-before B 和 B happens-before A 两个执行的结果是相同的，JMM认为这种重排序是合法的。 重排序数据依赖性如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。 as-if-serial语义as-if-serial语义的意思是： 不管怎么重排序，（单线程）程序的执行结果不能被改变。编译器和处理器都应该遵循as-if-serial语义123int a = 1; //Aint b = 2; //Bint c = 1 + 2; //C 因为as-if-serial语义，所以程序执行的顺序只会有两种，分别是 A-B-C 和 B-A-C 执行的结果不会改变。但要注意的是，这种语义仅是针对单线程对重排序的处理，对于多线程来说，重排序依然会对程序产生一些奇奇怪怪的影响。 顺序一致性顺序一致性内存模型是一个理想化参考模型，为程序员提供了极强的内存可见性保证。内存一致性模型有两大特性: 一个线程中的所有操作都必须按照程序的顺序来执行 （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个造作都必须原子执行且立刻对所有线程可见 在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存读/写操作。从上图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读/写操作串行化。 假设有两个线程A和B并发执行。其中A线程有三个操作，它们在程序中的顺序是：A1-&gt;A2-&gt;A3。B线程也有三个操作，它们在程序中的顺序是：B1-&gt;B2-&gt;B3。假设这两个线程使用监视器来正确同步：A线程的三个操作执行后释放监视器，随后B线程获取同一个监视器。那么程序在顺序一致性模型中的执行效果将如下图所示：假设这两个线程没有同步，那么在顺序一致性模型中执行的结果也会是一致的:但是，这仅仅是一个理想化的模型，JMM在执行中并没有这个保证，因此在多线程执行的过程中还是存在着重排序带来的一系列问题。 volatile 内存语义vloatile 的特性一个volatile变量的单个读/写操作，与一个普通变量的读/写操作都是使用同一个锁来同步，他们之间的执行效果相同。简而言之，volatile变量自身具有以下特性： 可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入 原子性：对任意单个volatile变量的读/写具有原子性，对于符合操作便不具有原子性。12345678910111213class VolatileFeaturesExample&#123; volatile long v1 = 0L; public void set(long l)&#123; v1 = l; &#125; public void getAndIncrement()&#123; v1++; &#125; public long get()&#123; return v1; &#125;&#125; 12345678910111213class VolatileFeaturesExample&#123; long v1 = 0L; public synchronized void set(long l)&#123; v1 = l; &#125; public void getAndIncrement()&#123; v1++; &#125; public synchronized long get()&#123; return v1; &#125;&#125; volatile 写-读的内存语义 当写一个volatile变量时，JMM会把该线程对应的本地内存的共享变量刷新到主内存 由图可知，flag是一个volatile变量，当线程A书写变量flag为true时，会将变量值写到共享内存中，这时候本地内存B中包含的变量值已经无效，线程B必须从共享内存中读取flag的值。 将volatile写和读两个步骤综合起来看的话，在线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将立即变得对线程B可见。 总结（线程之间通信的实现）： 线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（对共享变量所做修改的）消息。 线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（写在这个volatile变量之前对共享变量所做修改的）消息。 volatile 内存语义的实现从图中可以看出：当第二个操作为volatile写时，一律不允许重排序；当第一个操作为volatile写时，一律不允许重排序操作；当第一个操作是volatile写，第二个操作是volatile读时，不允许重排序操作 因此为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。 在每个volatile写操作前插入StoreStore屏障 在每个volatile写操作后插入StoreLoad屏障 在每个volatile读操作前面插入LoadLoad屏障 在每个volatile读操作后面插入StoreLoad屏障 实际执行的时候，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。最后的StoreLoad屏障编译器在编译的时候都会加上，因为不知道在volatile写之后到底会执行什么操作（假如是return操作的话就没有必要写这个屏障）,但是编译器保险起见都会加上这个屏障。从这里可以看出，编译器会自动的省略掉没有必要的屏障，但要保障结果的正常。由于不同的处理器有不同的“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。例如X86的处理器仅仅会对写-读操作进行重排序，因此对于上述的图中的叙述，LoadLoad屏障、LoadStore屏障和SotreStore屏障将不会被处理器加入，只留下一个StoreLoad屏障。 锁和final的内存语义锁的内存语义锁的释放-获取建立的happens-before关系12345678910class MonitorExample&#123; int a = 0; public synchronized void writer()&#123; //1 a++; //2 &#125; //3 public synchronized void reader()&#123; //4 int i = a ; //5 &#125; //6&#125; 当线程A执行writer()方法，线程B执行reader()方法，根据happens-before规则可知： 根据程序次序规则，1 happens-before 2，2&gt;3 , 4&gt;5 , 5&gt;6 根据监视器锁规则，3&gt;4 根据happens-before 的传递性，2&gt;5，因此会当线程A写入a的值之后，线程B才会读取到最新的a值也就是说，线程A在释放锁之前所有可见的共享变量，在线程B获得同一个锁之后，将立刻变得对B线程可见 锁的释放和获取的内存语义当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。在另一个线程获取锁时，JMM会把线程对应的本地内存置为无效。从而使得被监视器保护的临界代码必须从住内存中读取共享变量。可以看出，锁的释放-获得内存语义和volatile写-读的内存语义有着相同之处： 线程A释放一个锁，实际上是线程A向接下来将要获取这个锁的某个线程发出（线程A对共享变量所做的修改）消息 线程B获取一个锁，实质上是线程B接受了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。 锁内存语义的实现 完美解释ReentrantLock的博客 从这篇博客中可以看到，在ReentrantLock中分为公平锁和非公平锁，两者的区别在于多个Node连起来的虚拟队列，队列中有head和tail。针对公平锁，head是不带线程的特殊Node，只有next，而最新一个请求锁的线程取锁失败时就把它添加到队尾，也就是tail。但是对于非公平锁，新请求锁的线程就会插队，也许会插到最前面，也许不会。 总的来说，公平锁和非公平锁的不同在于： 公平锁在释放锁的最后写volatile变量state，在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放所的线程在写volatile变量之前可见的共享变量，在获得锁的线程读取同一个volatile变量之后将立即变得对获取锁的线程可见。 非公平锁中实现真正开始加锁的源代码为 123protected final boolean compareAndSetState(int expect , int update)&#123; return unsafe.compareAndSwapInt(this,stateOffset,expect,update);&#125; 此操作具有volatile读和写的内存语义，从处理器的角度来看的话，程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序在多处理器上运行则加上lock前缀，如果在单处理器上运行则不需要加上lock前缀。由于汇编代码加上lock前缀正是volatile语义的实现，因此具有volatile读和写的内存语义。 总的来说，锁的释放-获取内存语义的实现至少有以下两种方式： 利用volatile变量的写-读所具有的内存语义 利用CAS(compareAndSet)所附带的volatile读和写的内存语义。 final域的内存语义final域的重排序规则对于final域，编译器和处理器要遵守两个重排序规则 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序 通过一段代码来说明这个问题1234567891011121314151617181920public class FinalExample&#123; int i; final int j; static FinalExample obj; public FinalExample()&#123; //构造函数 i = 1; j = 2; //写final域 &#125; public static void writer()&#123; //线程A执行 obj = new FinalExample(); &#125; public static void reader()&#123; //线程B执行 FinalExample object = obj; //读对象引用 int a = object.i; int b = object.j; //读final域 &#125;&#125; 由上面的两个重排序规则可以得到，在线程A执行将构造对象的引用赋值给一个引用变量，也就是new一个FinalExample时，会先将2赋值给final域j之后，再将这个new的对象赋值为obj，这两个步骤不会重排序。在线程B执行reader方法时，读对象的引用和读final域这两个步骤也不会进行重排序，否则如果先执行读final域时，这个时候object还未被赋值，便有可能会产生异常。 写final域的重排序规则写final域的重排序规则禁止把两个final域的写重排序到构造函数之外，包含两个方面： JMM禁止编译器把final域的写重排序到构造函数之外 编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障会禁止处理器把final域的写重排序到构造函数之外。上面的代码中，final域有这样的重排序规则，而对于普通变量则没有这样的规则，所以i = 1 可能会被重排序到构造函数之外。 读final域的重排序规则规则为：在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（仅仅针对编译器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。 在上面那个图可以看到，假如读对象普通域i被重排序到读对象引用obj之前的话，那将会产生错误。所以有final读这个重排序规则之后，假如obj先被线程A初始化了，那么final域的j一定会读取到2，假如还未被线程A初始化，那么读取的将会是null，也不会产生异常。 final域为引用类型对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在构造函数内对一个final引用对象的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序 12345678910111213141516171819public class FinalExample&#123; final int[] intArray; static FinalExample obj; public FinalExample()&#123; intArray = new intp[1]; intArray[0] = 1; &#125; public static void writerOne()&#123; //线程A执行 obj = new FinalExample(); &#125; public static void writeTwo()&#123; //线程B执行 obj.intArray[0] = 2; &#125; public static void reader()&#123; //线程C执行 if(obj != null)&#123; int templ = obj.intArray[0]; &#125; &#125;&#125; 从上面的程序可以看到，writerOne()方法执行的时候会先将构造函数执行完毕之后再将之赋值给obj对象，这两个步骤不会进行重排序。由于线程B和线程C存在竞争关系，JMM不能保证线程B的写入对线程C可见，所以templ的结果有可能时1也有可能是2，要解决这个办法，可以加上锁机制，或者使用volatile变量来确保内存的可见性。","categories":[],"tags":[{"name":"并发","slug":"并发","permalink":"http://wildergao.github.io/tags/并发/"}]}]}